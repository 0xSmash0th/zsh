# This set of functions implements a sort of magic history searching.
# After predict-on, typing characters causes the editor to look backward
# in the history for the first line beginning with what you have typed so
# far.  After predict-off, editing returns to normal for the line found.
# In fact, you often don't even need to use predict-off, because if the
# line doesn't match something in the history, adding a key performs
# standard completion --- though editing in the middle is liable to delete
# the rest of the line.
#
# The setting of compmatchers means that if you use the completion system,
# you should be able to type TAB at almost any point to advance the cursor
# to the next "interesting" character position (usually the end of the
# current word, but sometimes somewhere in the middle of the word).  And
# of course as soon as the entire line is what you want, you can accept
# with RETURN, without needing to move the cursor to the end first.
#
# To use it:
#   autoload -U predict-on
#   zle -N predict-on
#   zle -N predict-off
#   bindkey '...' predict-on
#   bindkey '...' predict-off
# Note that all functions are defined when you first type the predict-on
# key, which means typing the predict-off key before that gives a harmless
# error message.
#
# This uses the configuration keys starting with `predict_'.

predict-on() {
  zle -N self-insert insert-and-predict
  zle -N magic-space insert-and-predict
  zle -N backward-delete-char delete-backward-and-predict
  zle -N delete-char-or-list delete-no-predict
}
predict-off() {
  zle -A .self-insert self-insert
  zle -A .magic-space magic-space
  zle -A .backward-delete-char backward-delete-char
}
insert-and-predict () {
  emulate -L zsh
  if [[ ${RBUFFER[1]} = ${KEYS[-1]} ]]
  then
    # same as what's typed, just move on
    ((++CURSOR))
  else
    LBUFFER="$LBUFFER$KEYS"
    if [[ $LASTWIDGET == (self-insert|magic-space|backward-delete-char) ]]
    then
      if ! zle .history-beginning-search-backward
      then
	RBUFFER=""
	if [[ ${KEYS[-1]} != ' ' ]]
	then
	  unsetopt automenu
	  integer curs=$CURSOR pos nchar=${#LBUFFER//[^${KEYS[-1]}]}
	  local -a +h comppostfuncs
	  comppostfuncs=( predict-limit-list )
	  zle complete-word ${(s.:.)compconfig[predict_completer]}
	  # Decide where to leave the cursor. The dummy loop is used to
	  # get out of that `case'.
	  while true; do
	    case $compconfig[predict_cursor] in
	    (complete)
	      # At the place where the completion left it, if it is after
	      # the character typed.
	      [[ ${LBUFFER[-1]} = ${KEYS[-1]} ]] && break
	      ;&
	    (key)
	      # Or maybe at the n'th occurrence of the character typed.
	      pos=${BUFFER[(in:nchar:)${KEYS[-1]}]}
	      if [[ pos -gt curs ]]; then
	        CURSOR=$pos
	        break
	      fi
	      ;&
	    (*)
	      # Or else at the previous position.
	      CURSOR=$curs
	    esac
	    break
	  done
	fi
      fi
    fi
  fi
  return 0
}
delete-backward-and-predict() {
  emulate -L zsh
  if [[ -n "$LBUFFER" ]]
  then
    # If the last widget was e.g. a motion, then probably the intent is
    # to actually edit the line, not change the search prefix.
    if [[ $LASTWIDGET == (self-insert|magic-space|backward-delete-char) ]]
    then
      ((--CURSOR))
      zle .history-beginning-search-forward || RBUFFER=""
      return 0
    else
      # Depending on preference, you might call "predict-off" here.
      LBUFFER="$LBUFFER[1,-2]"
    fi
  fi
}
delete-no-predict() {
  [[ $WIDGET != delete-char-or-list || -n $RBUFFER ]] && predict-off
  zle .$WIDGET "$@"
}

# This is a helper function for autocompletion to prevent long lists
# of matches from forcing a "do you wish to see all ...?" prompt.

predict-limit-list() {
  if (( compstate[list_lines]+BUFFERLINES > LINES ||
	compstate[nmatches] > compstate[list_max] ))
  then
    compstate[list]=''
    compstate[force_list]=yes
  elif [[ $compconfig[predict_list] = always ]]
  then
    compstate[force_list]=yes
  fi
}

# Handle zsh autoloading conventions

[[ -o kshautoload ]] || predict-on "$@"
