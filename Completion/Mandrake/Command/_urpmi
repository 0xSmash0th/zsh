#compdef urpmi urpmi.addmedia urpmi.removemedia urpmi.update

_urpmi_cache_policy() {
    local -a synthesis
    local i
    synthesis=(/var/lib/urpmi/synthesis.*)
    for i in $synthesis; do
	[[ -e "$1" && -e "$i" && "$1" -nt "$i" ]] && return 1
    done
    return 0
}
    
_urpmi() {
    local state context line ret=1
    typeset -A opt_args
    local update_policy

    zstyle -s ":completion:*:*:urpmi:*" cache-policy update_policy
    if [[ -z "$update_policy" ]]; then
	zstyle ":completion:*:*:urpmi:*" cache-policy _urpmi_cache_policy
    fi

    case "$service" in
	urpmi.addmedia )
	    _arguments -A '-*' \
		"(--wget)--curl[use curl to retrieve distant files]" \
		"--distrib[automatically create all media from an installation medium]" \
		"--update[mark as update media]" \
		"(--curl)--wget[use wget to retrieve distant files]" \
		"-c[clean headers cache directory]" \
		"-f[force generation of hdlist files]" \
		"-h[try to find and use synthesis or hdlist file]" \
		":name of media: " \
		":media URL:->media_url" \
		": :(with)" \
		":relative path to hdlist file: " \
	     && ret=0
	;;
	urpmi.removemedia )
	    _arguments -A '-*' \
		"(:)-a[select all media]" \
		"(-a)"{,\*}": :->urpmi_media" \
	     && ret=0
	;;
	urpmi.update )
	    _arguments -A '-*' \
		"(--wget)--curl[use curl to retrieve distant files]" \
		"(--curl)--wget[use wget to retrieve distant files]" \
		"(:)-a[select all non-removable media]" \
		"-c[clean /var/cache/urpmi/headers on exit]" \
		"-d[force complete computation of depslist.ordered file]" \
		"*-f[force generation of hdlist files]" \
		"(-a)"{,\*}": :->urpmi_media" \
	     && ret=0
	;;
	urpmi )
	    _arguments -A '-*' \
		"(: -)--help[print usage information]" \
		"(--help)--allow-medium-change[allow change of removable media]" \
		"(--help)--auto[do not ask any questions]" \
		"(--help)--auto-select[select the packages to update]" \
		"(--help -X)--best-output[automatically select text or X interface]" \
		"(--help)--complete[use parsehdlist server to complete selection]" \
		"(--help --wget)--curl[use curl to retrieve distant files]" \
		"(--help)--force[proceed even when some packages do not exist]" \
		"(--help)--update[use only update media]" \
		"(--help --curl)--wget[use wget to retrieve distant files]" \
		"(--help)-a[select all packages matching command line]" \
		"(--help -m -M)-m[choose minimum closure of requires (default)]" \
		"(--help -m -M)-M[choose maximum closure of requires]" \
		"(--help)-p[allow search in provides]" \
		"(--help -q -v)-q[be quiet]" \
		"(--help -q -v)-v[verbose mode]" \
		"(--help --best-output)-X[use X interface]" \
		"(--help)"{,\*}": :->urpmi_rpms" \
	    && ret=0
	;;
    esac

    case "$state" in
	media_url )
	    if compset -P file:// || compset -P removable://; then
		_files -W / -/ && ret=0
	    elif [[ -prefix '(ftp|http)://' ]]; then
		_urls && ret=0
	    else
		_wanted urpmi_media_type expl 'type of media' \
		    compadd -- file:// http:// ftp:// removable:// && ret=0
	    fi
	;;
	urpmi_media )
	    local source media brace ret=1
	    while read source media brace; do
		[[ "$brace" != "{" ]] && continue
		_wanted urpmi_media expl 'available media' \
		    compadd -- "$source"
		ret=0
	    done < /etc/urpmi/urpmi.cfg
	;;
	urpmi_rpms )
	    local pkg foo expl
	    local -a pkgs
	    local -a synthesis
	    synthesis=(/var/lib/urpmi/synthesis.*(N))
	    (( $#synthesis > 0 )) && {
		if _cache_invalid _urpmi_rpms || ! _retrieve_cache _urpmi_rpms; then
		    pkgs=($(zcat $synthesis | \
			 grep @info@ | cut -d @ -f 3 | sed -e 's/\.[^.]*$//'))
		    _store_cache _urpmi_rpms pkgs
		fi
	    }
	    (( $#pkgs > 0 )) && \
		_wanted urpmi_rpms expl 'urpmi RPMs to install' \
		    compadd -a pkgs && ret=0
	    (( $EUID == 0 )) && \
		_wanted urpmi_files expl 'RPM files to install' \
		    _files -g '*.(#i)rpm' && ret=0
	;;
    esac

    return $ret
}

_urpmi "$@"
