#autoload

# If this is a listing widget and there is already an old list,
# and either the compconfig key oldlist_list is `always', or it is not `never'
# and the list is not already shown, then use the existing list for listing
# (even if it was generated by another widget).
# Do this also if there is an old list and it was generated by the
# completer named by the oldlist_list key.
if [[ -n $compstate[old_list] && $compconfig[oldlist_list] != never ]]; then
  if [[ $WIDGET = *list* &&
        ( $compconfig[oldlist_list] = always ||
	  $compstate[old_list] != shown ) ]]; then
    compstate[old_list]=keep
    return 0
  elif [[ $compconfig[oldlist_list] = *${_lastcomp[completer]}* ]]; then
    [[ "$_lastcomp[insert]" = unambig* ]] && compstate[to_end]=single
    compstate[old_list]=keep
    if [[ -o automenu ]]; then
      compstate[insert]=menu
    else
      compadd -Qs "$SUFFIX" - "$PREFIX"
    fi
    return 0
  fi
fi

# If this is a completion widget, and we have a completion inserted already,
# and the compconfig key oldlist_menu is not never, then we cycle through the
# existing list (even if it was generated by another widget).

if [[ $compconfig[oldlist_menu] = verbose &&
      $LASTWIDGET = _verbose_list && $WIDGET != _verbose_list &&
      -z $compstate[old_insert] &&
      -n $compstate[old_list] ]]; then
  compstate[old_list]=keep
elif [[ $WIDGET = *complete(|-prefix|-word) &&
      $compconfig[oldlist_menu] != (never|verbose) ]]; then
  if [[ -n $compstate[old_insert] ]]; then
    compstate[old_list]=keep
    if [[ $WIDGET = *reverse* ]]; then
      compstate[insert]=$(( compstate[old_insert] - 1 ))
    else
      compstate[insert]=$(( compstate[old_insert] + 1 ))
    fi
  else
    return 1
  fi
  return 0
fi

return 1
