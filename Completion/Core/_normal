#autoload

local comp command cmd1 cmd2 pat val name i ret=1 _compskip="$_compskip"

# If we get the option `-s', we don't reset `_compskip'. This ensures
# that a value set in the function for the `-first-' context is kept,
# but that we still use pattern functions when we were called form
# another completion function.

[[ "$1" = -s ]] || _compskip=''

# Completing in command position? If not we set up `cmd1' and `cmd2' as
# two strings we have to search in the completion definition arrays (e.g.
# a path and the last path name component).

command="$words[1]"
if [[ CURRENT -eq 1 ]]; then
  comp="$_comps[-command-]"
  [[ -z "$comp" ]] || "$comp" && ret=0

  return ret
elif [[ "$command[1]" == '=' ]]; then
  eval cmd1\=$command
  cmd2="$command[2,-1]"
elif [[ "$command" == */* ]]; then
  cmd1="$command"
  cmd2="${command:t}"
else
  cmd1="$command"
  if zmodload -e parameter; then
    cmd2="$commands[$command]"
  else
    cmd2=$(whence -p $command)
  fi
fi

# See if there are any matching pattern completions.

if [[ "$_compskip" != (all|*patterns*) ]]; then
  for i in "$_patcomps[@]"; do
    pat="${i% *}"
    val="${i#* }"
    if [[ "$cmd1" == $~pat || "$cmd2" == $~pat ]]; then
      "$val" && ret=0
      if [[ "$_compskip" = *patterns* ]]; then
        break
      elif [[ "$_compskip" = all ]]; then
        _compskip=''
        return ret
      fi
    fi
  done
fi

# Now look up the two names in the normal completion array.

name="$cmd1"
comp="$_comps[$cmd1]"

if [[ -z "$comp" ]]; then
  name="$cmd2"
  comp="$_comps[$cmd2]"
fi

# And generate the matches, probably using default completion.

if [[ -n "$comp" ]]; then
  _compskip=patterns
  "$comp" && ret=0
  [[ "$_compskip" = (all|*patterns*) ]] && return ret
else
  if [[ "$_compskip" != *default* ]]; then
    name=-default-
    comp="$_comps[-default-]"
  fi
fi

if [[ "$_compskip" != (all|*patterns*) ]]; then
  for i in "$_postpatcomps[@]"; do
    pat="${i% *}"
    val="${i#* }"
    if [[ "$cmd1" == $~pat || "$cmd2" == $~pat ]]; then
      _compskip=default
      "$val" && ret=0
      if [[ "$_compskip" = *patterns* ]]; then
	break
      elif [[ "$_compskip" = all ]]; then
        _compskip=''
        return ret
      fi
    fi
  done
fi

[[ "$name" = -default- && -n "$comp" && "$_compskip" != (all|*default*) ]] &&
  "$comp" && ret=0

_compskip=''

return ret
