# Initialisation for new style completion. This mainly contains some helper
# functions and aliases. Everything else is split into different files that
# will automatically be made autoloaded (see the end of this file).
# The names of the files that will be considered for autoloading have to
# start with an underscores (like `_setopt').
# The first line of these files will be read and has to say what should be
# done with its contents:
#
#   `#compdef <names ...>'
#     If the first line looks like this, the file is autoloaded as a
#     function and that function will be called to generate the matches
#     when completing for one of the commands whose <names> are given.
#
#   `#compdef -p <pattern>'
#     This defines a function that should be called to generate matches
#     for commands whose name matches <pattern>. Note that only one pattern
#     may be given.
#
#   `#compdef -k <style> [ <key-sequence> ... ]
#     This is used to bind special completions to all the given
#     <key-sequence>(s). The <style> is the name of one of the built-in
#     completion widgets (complete-word, delete-char-or-list,
#     expand-or-complete, expand-or-complete-prefix, list-choices,
#     menu-complete, menu-expand-or-complete, or reverse-menu-complete).
#     This creates a widget behaving like <style> so that the
#     completions are chosen as given in the the rest of the file,
#     rather than by the context.  The widget has the same name as
#     the autoload file and can be bound using bindkey in the normal way.
#
#   `#compdef -K <widget-name> <style> <key-sequence> [ ... ]
#     This is similar to -k, except it takes any number of sets of
#     three arguments.  In each set, the widget <widget-name> will
#     be defined, which will behave as <style>, as with -k, and will
#     be bound to <key-sequence>, exactly one of which must be defined.
#     <widget-name> must be different for each:  this must begin with an
#     underscore, else one will be added, and should not clash with other
#     completion widgets (names based on the name of the function are the
#     clearest), but is otherwise arbitrary.  It can be tested in the
#     function by the parameter $WIDGET.
#
#   `#autoload'
#     this is for helper functions that are not used to
#     generate matches, but should automatically be loaded
#     when they are called
#
# Note that no white space is allowed between the `#' and the rest of
# the string.
#
# Functions that are used to generate matches should return zero if they
# were able to add matches and non-zero otherwise.
#
# See the file `compdump' for how to speed up initialisation.

# If we got the `-d'-flag, we will automatically dump the new state (at
# the end).  This takes the dumpfile as an argument.  -d (with the
# default dumpfile) is now the default; to turn off dumping use -D.

emulate -L zsh

typeset _i_dumpfile _i_files _i_line _i_done _i_dir _i_autodump=1
typeset _i_tag _i_file _i_addfiles

while [[ $# -gt 0 && $1 = -[dDf] ]]; do
  if [[ "$1" = -d ]]; then
    _i_autodump=1
    shift
    if [[ $# -gt 0 && "$1" != -[df] ]]; then
      _i_dumpfile="$1"
      shift
    fi
  elif [[ "$1" = -D ]]; then
    _i_autodump=0
    shift
  elif [[ "$1" = -f ]]; then
    # Not used any more; use _compdir
    shift
    shift
  fi
done

# The associative array containing the definitions for the commands.
# Definitions for patterns will be stored in the normal arrays `_patcomps'
# and `_postpatcomps'.

typeset -gA _comps
_patcomps=()
_postpatcomps=()

# The associative array use to report information about the last
# cmpletion to the outside.

typeset -gA _lastcomp

# This is the associative array used for configuration.

typeset -gA compconfig

# Standard initialisation for `compconfig'.
if [[ -n $_i_dumpfile ]]; then
  # Explicitly supplied dumpfile.
  compconfig[dumpfile]="$_i_dumpfile"
else
  compconfig[dumpfile]="${ZDOTDIR:-$HOME}/.zcompdump"
fi

(( ${+compconfig[correct_accept]} )) || compconfig[correct_accept]=2n
(( ${+compconfig[correct_prompt]} )) ||
  compconfig[correct_prompt]='correct to:'
(( ${+compconfig[completer]} )) || compconfig[completer]=_complete

# This holds the style definitions.

typeset -gA _compstyles

# This can hold names of functions that are to be called after all
# matches have been generated.

comppostfuncs=()

# Loading it now ensures that the `funcstack' parameter is always correct.

zmodload -i parameter

# This function is used to register or delete completion functions. For
# registering completion functions, it is invoked with the name of the
# function as it's first argument (after the options). The other
# arguments depend on what type of completion function is defined. If
# none of the `-p' and `-k' options is given a function for a command is
# defined. The arguments after the function name are then interpreted as
# the names of the command for which the function generates matches.
# With the `-p' option a function for a name pattern is defined. This 
# function will be invoked when completing for a command whose name 
# matches the pattern given as argument after the function name (in this
# case only one argument is accepted).
# The option `-P' is like `-p', but the function will be called after
# trying to find a function defined for the command on the line if no
# such function could be found.
# With the `-k' option a function for a special completion keys is 
# defined and immediatly bound to those keys. Here, the extra arguments
# are the name of one of the builtin completion widgets and any number
# of key specifications as accepted by the `bindkey' builtin.
# In any case the `-a' option may be given which makes the function
# whose name is given as the first argument be autoloaded. When defining
# a function for command names the `-n' option may be given and keeps
# the definitions from overriding any previous definitions for the
# commands; with `-k', the `-n' option prevents compdef from rebinding
# a key sequence which is already bound.
# For deleting definitions, the `-d' option must be given. Without the
# `-p' option, this deletes definitions for functions for the commands
# whose names are given as arguments. If combined with the `-p' option
# it deletes the definitions for the patterns given as argument.
# The `-d' option may not be combined with the `-k' option, i.e.
# definitions for key function can not be removed.
#
# Examples:
#
#  compdef -a foo bar baz
#    make the completion for the commands `bar' and `baz' use the
#    function `foo' and make this function be autoloaded
#
#  compdef -p foo 'c*'
#    make completion for all command whose name begins with a `c'
#    generate matches by calling the function `foo' before generating
#    matches defined for the command itself
#
#  compdef -k foo list-choices '^X^M' '\C-xm'
#    make the function `foo' be invoked when typing `Control-X Control-M'
#    or `Control-X m'; the function should generate matches and will
#    behave like the `list-choices' builtin widget
#
#  compdef -d bar baz
#   delete the definitions for the command names `bar' and `baz'

compdef() {
  local opt autol type func delete new i

  # Get the options.

  if [[ $#* -eq 0 ]]; then
    echo "compdef needs parameters"
    return 1
  fi
  
  while getopts "anpPkKd" opt; do
    case "$opt" in
    a)    autol=yes;;
    n)    new=yes;;
    [pPkK]) if [[ -n "$type" ]]; then
            # Error if both `-p' and `-k' are given (or one of them
	    # twice).
            echo "$0: type already set to $type"
	    return 1
	  fi
	  if [[ "$opt" = p ]]; then
	    type=pattern
	  elif [[ "$opt" = P ]]; then
	    type=postpattern
	  elif [[ "$opt" = K ]]; then
	    type=widgetkey
	  else
	    type=key
	  fi
	  ;;
    d) delete=yes;;
    esac
  done
  shift OPTIND-1

  if [[ $#* -eq 0 ]]; then
    echo "compdef needs parameters"
    return 1
  fi
  
  if [[ -z "$delete" ]]; then
    # Adding definitions, first get the name of the function name
    # and probably do autoloading.

    func="$1"
    [[ -n "$autol" ]] && autoload -U "$func"
    shift

    case "$type" in
    pattern)
      if [[ $# -gt 1 ]]; then
        echo "$0: only one pattern allowed"
	return 1
      fi
      # Patterns are stored in strings like `c* foo', with a space
      # between the pattern and the function name.

      _patcomps=("$_patcomps[@]" "$1 $func")
      ;;
    postpattern)
      if [[ $# -gt 1 ]]; then
        echo "$0: only one pattern allowed"
	return 1
      fi
      _postpatcomps=("$_postpatcomps[@]" "$1 $func")
      ;;
    widgetkey)
      while [[ -n $1 ]]; do
	if [[ $# -lt 3 ]]; then
	  echo "$0: compdef -K requires <widget> <comp-widget> <key>"
	  return 1
	fi
	[[ $1 = _* ]] || 1="_$1"
	[[ $2 = .* ]] || 2=".$2"
	zle -C "$1" "$2" "$func"
	if [[ -n $new ]]; then
	  bindkey "$3" | read -A opt
	  [[ $opt[-1] = undefined-key ]] && bindkey "$3" "$1"
	else
	  bindkey "$3" "$1"
	fi
	shift 3
      done
      ;;	 
    key)
      if [[ $# -lt 2 ]]; then
        echo "$0: missing keys"
	return 1
      fi

      # Define the widget.
      if [[ $1 = .* ]]; then
	zle -C "$func" "$1" "$func"
      else
	zle -C "$func" ".$1" "$func"
      fi
      shift

      # And bind the keys...
      for i; do
        if [[ -n $new ]]; then
	   bindkey "$i" | read -A opt
	   [[ $opt[-1] = undefined-key ]] || continue
	fi
        bindkey "$i" "$func"
      done
      ;;
    *)
      # For commands store the function name in the `_comps'
      # associative array, command names as keys.
      if [[ -z "$new" ]]; then
	for i; do
	  _comps[$i]="$func"
	done
      else
        for i; do
          [[ "${+_comps[$i]}" -eq 0 ]] && _comps[$i]="$func"
        done
      fi
      ;;
    esac
  else
    # Handle the `-d' option, deleting.
    case "$type" in
    pattern)
      # Note the space.
      for i; do
        _patcomps=("${(@)_patcomps:#$i *}")
      done
      ;;
    postpattern)
      for i; do
        _postpatcomps=("${(@)_postpatcomps:#$i *}")
      done
      ;;
    key)
      # Oops, cannot do that yet.

      echo "$0: cannot restore key bindings"
      return 1
      ;;
    *)
      # Deleting definitons for command is even simpler.
      for i; do
        unset "_comps[$i]"
      done
    esac
  fi
}

# Functional interface to configuration. This takes its arguments
# and sets the according values in `compconfig'.
# Arguments may be `foo=bar' to set key `foo' to `bar' or `baz' to
# set key `baz' to the empty string.
# If no arguments are given, all configurations keys set are displayed.
# With the option `-l' as the first argument, the other arguments are
# taken to be key names and the values for theses keys are printed, one
# per line.
# When listing is done and the `-L' option is given, the keys and
# values are printed as invocations for this function, usable to be put
# inte a setup script.

compconf() {
  local i opt list

  while getopts "lL" opt; do
    if [[ "$opt" = l ]]; then
      [[ -z "$list" ]] && list=yes
    else
      list=long
    fi
  done
  shift OPTIND-1

  if (( $# )); then
    if [[ -n $list ]]; then
      for i; do
        if [[ $list = long ]]; then
	  (( ${+compconfig[$i]} )) && print "compconf $i='$compconfig[$i]'"
	else
          print $compconfig[$i]
	fi
      done
    else
      for i; do
        if [[ "$i" = *\=* ]]; then
          compconfig[${i%%\=*}]="${i#*\=}"
        else
          compconfig[$i]=''
        fi
      done
    fi
  else
    for i in ${(ok)compconfig}; do
      if [[ $list = long ]]; then
	print "compconf $i='$compconfig[$i]'"
      else
        print ${(r:25:)i} "$compconfig[$i]"
      fi
    done
  fi
}

# Very simple interface for setting styles:
#
#   compstyle context -styles... context -styles ...
#
# Where context is of the form cmd-pat:ctxt-pat:tag-pat.
#
# This will be improved if needed. Promised.

compstyle() {
  if (( ! $# )); then
    local pat

    for pat in "${(@k)_compstyles}"; do
      print -- "${(r:20:: :)pat} -- ${_compstyles[$pat]#??}"
    done

    return 0
  fi

  local sep pat test
  typeset -Z 2 num

  while (( $# )); do
    num=0
    for pat in "${(s:,:)1}"; do
      if [[ "$pat" = \* ]]; then
        (( num += 3 ))
      elif [[ "$pat" = any ]]; then
        (( num += 2 ))
      elif [[ "$pat" != "$pat:q" ]]; then
        (( num++ ))
      fi
    done

    pat="$1"
    shift

    sep=$argv[(I)[^-]*]

    if (( sep )); then
      _compstyles[$pat]="${num}${(j.:.)${(@)argv[1,sep-1]#-}}"
      shift sep-1
    else
      _compstyles[$pat]="${num}${(j.:.)${(@)argv#-}}"
      break
    fi
  done

  return 0
}

# Default styles.

compstyle '*,*,*' -description=yes -prefix-needed=yes -prefix-hidden=no

# Helper function for `_tags'. Will be moved into C-code.

comptry() {
  _tags=( "$_tags[@]" ":${(j.:.)argv}:" )
}

# Utility function to call a function if it exists.
#
# Usage: funcall <return> <name> [ <args> ... ]
#
# If a function named <name> is defined (or defined to be autoloaded),
# it is called. If <return> is given not the string `-' or empty, it is
# taken as the name of a parameter and the return status of the function
# called is stored in this parameter. All other arguments are given
# to the function called.
# The return value of this function is zero if the function was
# called and non-zero otherwise.

funcall() {
  local _name _ret

  [[ "$1" != (|-) ]] && _name="$1"

  shift

  if (( $+functions[$1] )); then
    "$@"
    _ret="$?"
    [[ -n "$_name" ]] && eval "${_name}=${_ret}"
    compstate[restore]=''
    return 0
  fi
  return 1
}

# Now we automatically make the definition files autoloaded.

typeset -U _i_files
_i_files=( ${^~fpath:/.}/_(|*[^~])(N:t) )
if [[ $#_i_files -lt 20 || $_compdir = */Core || -d $_compdir/Core ]]; then
  # Too few files:  we need some more directories,
  # or we need to check that all directories (not just Core) are present.
  if [[ -n $_compdir ]]; then
    _i_addfiles=()
    if [[ $_compdir = */Core ]]; then
      # Add all the Completion subdirectories
      _i_addfiles=(${_compdir:h}/*(/))
    elif [[ -d $_compdir/Core ]]; then
      # Likewise
      _i_addfiles=(${_compdir}/*(/))
    fi
    for _i_line in {1..$#i_addfiles}; do
      _i_file=${_i_addfiles[$_i_line]}
      [[ -d $_i_file && -z ${fpath[(r)$_i_file]} ]] ||
        _i_addfiles[$_i_line]=
    done
    fpath=($fpath $_i_addfiles)
    _i_files=( ${^~fpath:/.}/_(|*[^~])(N:t) )
  fi
fi


# Rebind the standard widgets
for _i_line in complete-word delete-char-or-list expand-or-complete \
  expand-or-complete-prefix list-choices menu-complete \
  menu-expand-or-complete reverse-menu-complete; do
  zle -C $_i_line .$_i_line _main_complete
done
zle -la menu-select && zle -C menu-select .menu-select _main_complete

_i_done=''

# Make sure compdump is available, even if we aren't going to use it.
autoload -U compdump compinstall

# If we have a dump file, load it.

if [[ -f "$compconfig[dumpfile]" ]]; then
  read -rA _i_line < "$compconfig[dumpfile]"
  if [[ _i_autodump -eq 1 && $_i_line[2] -eq $#_i_files ]]; then
    builtin . "$compconfig[dumpfile]"
    _i_done=yes
  fi
fi
if [[ -z "$_i_done" ]]; then
  for _i_dir in $fpath; do
    [[ $_i_dir = . ]] && continue
    for _i_file in $_i_dir/_(|*[^~])(N); do
      read -rA _i_line < $_i_file
      _i_tag=$_i_line[1]
      shift _i_line
      case $_i_tag in
      (\#compdef)
	if [[ $_i_line[1] = -[pPkK](n|) ]]; then
	  compdef ${_i_line[1]}na "${_i_file:t}" "${(@)_i_line[2,-1]}"
	else
	  compdef -na "${_i_file:t}" "${_i_line[@]}"
	fi
	;;
      (\#autoload)
	autoload -U ${_i_file:t}
	;;
      esac
    done
  done

  # If autodumping was requested, do it now.

  if [[ $_i_autodump = 1 ]]; then
    compdump
  fi
fi

unfunction compinit
autoload -U compinit
