#autoload

# This gets two arguments, a separator (which should be only one
# character) and an array. As usual, the array may be given by it's
# name or literal as in `(foo bar baz)' (words separated by spaces in
# parentheses).
# The parts of words from the array that are separated by the
# separator character are then completed independently.

local sep matches pref npref i tmp1 group expl menu pre suf opre osuf cpre
local opts sopts match
typeset -U tmp2

# Get the options.

group=()
expl=()
opts=()
sopts=()
while getopts "J:V:X:P:S:r:R:qM:12n" opt; do
  case "$opt" in
  [JV])   group=("-$opt" "$OPTARG");;
  X)      expl=(-X "$OPTARG");;
  P)      opts=( "$opts[@]" -P "$OPTARG")
          sopts=( "$sopts[@]" -P "$OPTARG");;
  [SrR])  sopts=( "$sopts[@]" -P "$OPTARG");;
  [q12n]) sopts=( "$sopts[@]" "-$opt");;
  M)      match="$OPTARG";;
  esac
done
shift OPTIND-1

# Get the arguments, first the separator, then the array. The array is 
# stored in `matches'. Further on this array will always contain those 
# words from the original array that still match everything we have
# tried to match while we walk through the string from the line.

sep="$1"
if [[ "${2[1]}" = '(' ]]; then
  matches=( ${2[2,-2]} )
else
  matches=( "${(@P)2}" )
fi

# In `pre' and `suf' we will hold the prefix and the suffix from the
# line while we walk through them. The original string are used 
# temporarily for matching.

pre="$PREFIX"
suf="$SUFFIX"
opre="$PREFIX"
osuf="$SUFFIX"
orig="$PREFIX$SUFFIX"

# Special handling for menucompletion?

[[ $compstate[insert] = (*menu|[0-9]*) || -n "$_comp_correct" ||
   ( $#compstate[pattern_match] -ne 0 &&
     "$orig" != "${orig:q}" ) ]] && menu=yes

# In `pref' we collect the unambiguous prefix path.

pref=''

# If the string from the line matches at least one of the strings,
# we use only the matching strings.

compadd -O tmp1 -M "r:|${sep}=* r:|=* $match" - "$matches[@]"

(( $#tmp1 )) && matches=( "$tmp1[@]" )

while true; do

  # Get the prefix and suffix for matching.

  if [[ "$pre" = *${sep}* ]]; then
    PREFIX="${pre%%${sep}*}"
    SUFFIX=""
  else
    PREFIX="${pre}"
    SUFFIX="${suf%%${sep}*}"
  fi

  # Check if the component for some of the possible matches is equal
  # to the string from the line. If there are such strings, we directly
  # use the stuff from the line. This avoids having `foo' complete to
  # both `foo' and `foobar'.

  tmp1=( "${(@M)matches:#${PREFIX}${SUFFIX}${sep}*}" )

  if (( $#tmp1 )); then
    npref="${PREFIX}${SUFFIX}${sep}"
  else
    # No exact match, see how many strings match what's on the line.

    compadd -O tmp1 - "${(@)matches%%${sep}*}"
    tmp2=( "$tmp1[@]" )
    tmp1=( "$tmp2[@]" )

    if [[ $#tmp1 -eq 1 ]]; then

      # Only one match. If there are still separators from the line
      # we just accept this component. Otherwise we insert what we 
      # have collected, probably giving it a separator character
      # as a suffix.

      if [[ "$pre$suf" = *${sep}* ]]; then
        npref="${tmp1[1]}${sep}"
      else
        matches=( "${(@M)matches:#${tmp1[1]}*}" )
	tmp2=( "${(@M)matches:#${tmp1[1]}${sep}*}" )

	PREFIX="${cpre}${pre}"
	SUFFIX="$suf"

	if (( $#tmp2 )); then
	  compadd "$group[@]" "$expl[@]" -p "$pref" -qS "$sep" "$opts[@]" \
                  -M "r:|${sep}=* r:|=* $match" - "$tmp1[1]"
        else
	  compadd "$group[@]" "$expl[@]" -p "$pref" "$sopts[@]" \
                  -M "r:|${sep}=* r:|=* $match" - "$tmp1[1]"
        fi
	return 0
      fi
    elif (( $#tmp1 )); then

      # More than one match. First we get all strings that match the
      # rest from the line.

      PREFIX="$pre"
      SUFFIX="$suf"
      compadd -O matches -M "r:|${sep}=* r:|=* $match" - "$matches[@]"

      if [[ "$pre" = *${sep}* ]]; then
 	PREFIX="${cpre}${pre%%${sep}*}"
	SUFFIX="${sep}${pre#*${sep}}${suf}"
      else
        PREFIX="${cpre}${pre}"
	SUFFIX="$suf"
      fi

      if [[ -n "$menu" ]]; then
        # With menucompletion we just add matches for the matching
        # components with the prefix we collected and the rest from the
        # line as a suffix.

        tmp2="$pre$suf"
        if [[ "$tmp2" = *${sep}* ]]; then
          compadd "$group[@]" "$expl[@]" "$sopts[@]" \
                  -p "$pref" -s "${sep}${tmp2#*${sep}}" \
                  -M "r:|${sep}=* r:|=* $match" - "$tmp1[@]"
        else
          compadd "$group[@]" "$expl[@]" -p "$pref" "$sopts[@]" \
                  -M "r:|${sep}=* r:|=* $match" - "$tmp1[@]"
        fi
      else
        # With normal completion we add all matches one-by-one with
	# the unmatched part as a suffix. This will insert the longest
	# unambiguous string for all matching strings.

        for i in "${(@M)matches:#(${(j:|:)~tmp1})*}"; do
	  if [[ "$i" = *${sep}* ]]; then
            compadd "$group[@]" "$expl[@]" -S '' "$opts[@]" \
	            -p "$pref" -s "${i#*${sep}}" \
                    -M "r:|${sep}=* r:|=* $match" - "${i%%${sep}*}${sep}"
          else
            compadd "$group[@]" "$expl[@]" -S '' "$opts[@]" -p "$pref" \
                    -M "r:|${sep}=* r:|=* $match" - "$i"
          fi
        done
      fi
      return 0
    else
      # We are here if no string matched what's on the line. In this
      # case we insert the expanded prefix we collected if it differs
      # from the original string from the line.

      [[ "$orig" = "$pref$pre$suf" ]] && return 1

      PREFIX="${cpre}${pre}"
      SUFFIX="$suf"

      if [[ -n "$suf" ]]; then
        compadd "$group[@]" "$expl[@]" -s "$suf" "$sopts[@]" \
                -M "r:|${sep}=* r:|=* $match" - "$pref$pre"
      else
        compadd "$group[@]" "$expl[@]" -S '' "$opts[@]" \
                -M "r:|${sep}=* r:|=* $match" - "$pref$pre"
      fi
      return 0
    fi
  fi

  # We just accepted and/or expanded a component from the line. We
  # remove it from the matches (using only those that have a least
  # the skipped string) and ad it the `pref'.

  matches=( "${(@)${(@)${(@M)matches:#${npref}*}#*${sep}}:#}" )
  pref="$pref$npref"

  # Now we set `pre' and `suf' to their new values.

  if [[ "$pre" = *${sep}* ]]; then
    cpre="${cpre}${pre%%${sep}*}${sep}"
    pre="${pre#*${sep}}"
  elif [[ "$suf" = *${sep}* ]]; then
    cpre="${cpre}${pre}${suf%%${sep}*}${sep}"
    pre="${suf#*${sep}}"
    suf=""
  else
    # The string from the line is fully handled. If we collected an
    # unambiguous prefix and that differs from the original string,
    # we insert it.

    PREFIX="${opre}${osuf}"
    SUFFIX=""

    [[ -n "$pref" && "$orig" != "$pref" ]] &&
        compadd "$group[@]" "$expl[@]" -S '' "$opts[@]" \
                -M "r:|${sep}=* r:|=* $match" - "$pref"

    return
  fi
done
