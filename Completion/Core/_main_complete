#autoload

# The main loop of the completion code. This is what is called when 
# completion is attempted from the command line.
#
# Configuration keys used:
#
#  completer
#    This should be set to the names of the functions to generate the
#    matches separated by colons. E.g. with
#
#      compconf completer=_complete:_correct:_approximate
#
#    the code will first try normal completion. If that doesn't yield
#    any matches, correction is tried and if that doesn't yield
#    anything either, correcting completion is attempted.
#
#    These completer functions are only used when this function is called
#    without arguments. If arguments are given, they should be names of
#    completer functions which will then be called.
#
#  last_prompt
#    If this is set to `always' the cursor is moved up to the last prompt
#    after printing a list even if a numeric argument was given.


# If you want to complete only set or unset options for the unsetopt
# and setopt builtin, un-comment these lines:
#
#   local _set_options _unset_options
#
#   if zmodload -e parameter; then
#     _set_options=(${(k)options[(R)on]})
#     _unset_options=(${(k)options[(R)off]})
#   else
#     _set_options=("${(@f)$({ unsetopt kshoptionprint; setopt } 2>/dev/null)}")
#     _unset_options=("${(@f)$({ unsetopt kshoptionprint; unsetopt } 2>/dev/null)}")
#   fi
#
# This is needed because completion functions may set options locally
# which makes the output of setopt and unsetopt reflect a different
# state than the global one for which you are completing.


local comp ret=1

setopt localoptions nullglob rcexpandparam
unsetopt markdirs globsubst shwordsplit nounset ksharrays

# Special completion contexts after `~' and `='.

if compset -P 1 '\='; then
  compstate[context]=equal
elif [[ "$PREFIX" != */* && "$PREFIX[1]" = '~' ]]; then
  compset -p 1
  compstate[context]=tilde
fi

# Get the names of the completers to use in the positional parameters.

(( $# )) || set ${(s.:.)compconfig[completer]}

# And now just call the completer functions defined.

for comp; do
  if "$comp"; then
    ret=0
    break;
  fi
done

[[ "$compconfig[last_prompt]" = always ]] && compstate[last_prompt]=yes

_lastcomp=( "${(@kv)compstate}" )
_lastcomp[completer]="$comp"
_lastcomp[prefix]="$PREFIX"
_lastcomp[suffix]="$SUFFIX"
_lastcomp[iprefix]="$IPREFIX"
_lastcomp[isuffix]="$ISUFFIX"
_lastcomp[qiprefix]="$QIPREFIX"
_lastcomp[qisuffix]="$QISUFFIX"

return ret
