#autoload

# Generate all possible completions. Note that this is not intended as
# a normal completion function, but as one possible value for the
# completer style.

local comp name oldcontext
typeset -T curcontext="$curcontext" ccarray

oldcontext="$curcontext"

# If we have a user-supplied context name, use only that.

if [[ -n "$compcontext" ]]; then
  ccarray[3]="$compcontext"

  comp="$_comps[$compcontext]"
  [[ -z "$comp" ]] || "$comp"

  return
fi

# An entry for `-first-' is the replacement for `compctl -T'

comp="$_comps[-first-]"
if [[ ! -z "$comp" ]]; then
  ccarray[3]=-first-
  "$comp"
  if [[ "$_compskip" = all ]]; then
    _compskip=''
    (( compstate[nmatches] ))
    return
  fi
fi

# If we are inside `vared' and we don't have a $compcontext, we treat
# this like a parameter assignment. Which it is.

if [[ -n $compstate[vared] ]]; then
  if [[ $compstate[vared] = *\[* ]]; then
    # vared on an array-element
    compstate[parameter]=${compstate[vared]%%\[*}
    compstate[context]=value
  else
    # vared on a parameter, let's see if it is an array
    compstate[parameter]=$compstate[vared]
    if [[ ${(tP)compstate[vared]} = *(array|assoc)* ]]; then
      compstate[context]=array_value
    else
      compstate[context]=value
    fi
  fi
fi

# For arguments and command names we use the `_normal' function.

if [[ "$compstate[context]" = command ]]; then
  curcontext="$oldcontext"
  _normal -s
else
  # Let's see if we have a special completion definition for the other
  # possible contexts.

  local cname="-${compstate[context]:s/_/-/}-"

  ccarray[3]="$cname"

  comp="$_comps[$cname]"

  # If not, we use default completion, if any.

  if [[ -z "$comp" ]]; then
    if [[ "$_compskip" = *default* ]]; then
      _compskip=''
      return 1
    fi
    comp="$_comps[-default-]"
  fi
  [[ -z "$comp" ]] || "$comp"
fi

_compskip=''

(( compstate[nmatches] ))
