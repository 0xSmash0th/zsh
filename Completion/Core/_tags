#autoload

if (( $# )); then

  # We have arguments: the tags supported in this context.

  local curcontext="$curcontext" order tag nodef

  if [[ "$1" = -C?* ]]; then
    curcontext="${curcontext}:${1[3,-1]}"
    shift
  elif [[ "$1" = -C ]]; then
    curcontext="${curcontext}:${2}"
    shift 2
  else
    targs=()
  fi

  [[ "$1" = -(|-) ]] && shift

  if zstyle -a ":completion${curcontext}" group-order order; then
    local name

    for name in "$order[@]"; do
      compadd -J "$name"
      compadd -V "$name"
      compadd -J "$name" -1
      compadd -V "$name" -1
      compadd -J "$name" -2
      compadd -V "$name" -2
    done
  fi

  # Set and remember offered tags.

  comptags -i "$curcontext" "$@"

  _offered_tags=( "$_offered_tags[@]" "$@" )
  _last_tags=()

  # Sort the tags.

  if [[ -n "$_sort_tags" ]]; then
    "$_sort_tags" "$@"
  elif zstyle -a ":completion${curcontext}" tag-order order; then

    for tag in $order; do
      case $tag in
      -)     nodef=yes;;
      *\(\)) "${${tag%%[ 	]#\(\)}##[ 	]#}" "$@";;
      ?*)    comptry ${=tag};;
      esac
    done

    [[ -z "$nodef" ]] && comptry "$@"
  else
    comptry "$@"
  fi

  # Return non-zero if at least one set of tags should be used.

  comptags -T

  return
fi

# The other mode: switch to the next set of tags.

local tags

_failed_tags=( "$_failed_tags[@]" "$_last_tags[@]" )

# Return failure if no sets remaining.

comptags -N || return 1

# Otherwise get the next tags.

comptags -S _last_tags

_tried_tags=( "$_tried_tags[@]" "$_last_tags[@]" )

shift 1 "$prios"

return 0
