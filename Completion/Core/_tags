#autoload

if (( $# )); then

  # We have arguments: the tags supported in this context.

  local curcontext="$curcontext" order

  if [[ "$1" = -C?* ]]; then
    curcontext="${curcontext}:${1[3,-1]}"
    shift
  elif [[ "$1" = -C ]]; then
    curcontext="${curcontext}:${2}"
    shift 2
  else
    targs=()
  fi

  [[ "$1" = -(|-) ]] && shift

  if zstyle -a ":completion${curcontext}" group-order order; then
    local name

    for name in "$order[@]"; do
      compadd -J "$name"
      compadd -V "$name"
      compadd -J "$name" -1
      compadd -V "$name" -1
      compadd -J "$name" -2
      compadd -V "$name" -2
    done
  fi

  # Set and remember offered tags.

  comptags -i "$curcontext" "$@"

  _offered_tags=( "$_offered_tags[@]" "$@" )
  _last_tags=()

  # Call the function that sorts the tags into sets.

  "${_sort_tags:-_sort_tags}" "$@"

  # Return non-zero if at least one set of tags should be used.

  comptags -T

  return
fi

# The other mode: switch to the next set of tags.

local tags

_failed_tags=( "$_failed_tags[@]" "$_last_tags[@]" )

# Return failure if no sets remaining.

comptags -N || return 1

# Otherwise get the next tags.

comptags -S _last_tags

_tried_tags=( "$_tried_tags[@]" "$_last_tags[@]" )

shift 1 "$prios"

return 0
