#autoload

local prev

# A `--' as the first argument says that we should tell comptags to use
# the preceding function nesting level. This is only documented here because
# if everythings goes well, users won't have to worry about it and should
# not mess with it.

if [[ "$1" = -- ]]; then
  prev=-
  shift
fi

if (( $# )); then

  # We have arguments: the tags supported in this context.

  local curcontext="$curcontext" order tag nodef tmp tmp2 tmp3 als atag

  if [[ "$1" = -C?* ]]; then
    curcontext="${curcontext%:*}:${1[3,-1]}"
    shift
  elif [[ "$1" = -C ]]; then
    curcontext="${curcontext%:*}:${2}"
    shift 2
  else
    targs=()
  fi

  [[ "$1" = -(|-) ]] && shift

  if zstyle -a ":completion:${curcontext}:" group-order order; then
    local name

    for name in "$order[@]"; do
      compadd -J "$name"
      compadd -V "$name"
      compadd -J "$name" -1
      compadd -V "$name" -1
      compadd -J "$name" -2
      compadd -V "$name" -2
    done
  fi

  # Set and remember offered tags.

  comptags "-i$prev" "$curcontext" "$@"

  # Sort the tags.

  if [[ -n "$_sort_tags" ]]; then
    "$_sort_tags" "$@"
  else
    zstyle -a ":completion:${curcontext}:" tag-order order ||
      if [[ "$*" = *(arguments|values)* || "$*" = *options* ]] ;then
        order=( 'arguments values' options )
      else
        order=()
      fi

    for tag in $order; do
      case $tag in
      -)     nodef=yes;;
      *\(\)) if ! "${${tag%%[ 	]#\(\)}##[ 	]#}" "$@"; then
               nodef=yes
               break
             fi
             ;;
      \!*)   comptry "${(@)argv:#(${(j:|:)~${=~tag[2,-1]}})}";;
      ?*)    tmp=( ${${(s: :)${tag//\\\\ /$'\0'}}//$'\0'/ } ) tmp2=() tmp3=()
             for tag in "$tmp[@]"; do
	       if [[ "$tag" = *:* ]]; then
	         tmp2=( "$tmp2[@]" "${(@M)^argv:#${~tag%%:*}}:${tag#*:}" )
	       else
	         for atag in "${(@M)argv:#${~tag}}"; do
	           if zstyle -a ":completion:${curcontext}:${atag}" tag-aliases als; then
		     tmp3=( "$tmp3[@]" "$als[@]" )
		     tmp=( "${(@)tmp:#${atag}}" )
                   else
	             tmp2=( "$tmp2[@]" "$atag" )
		   fi
		 done
	       fi
	     done

	     comptry "${(@)tmp2:#(${(j:|:)~${(q)tmp%%:*}})}" "$tmp3[@]" "$tmp[@]"
	     ;;
      esac
    done

    if [[ -z "$nodef" ]]; then
      if (( $+_comp_default_tags )); then
        for tag in "$_comp_default_tags[@]"; do
	  if zstyle -a ":completion:${curcontext}:${tag}" tag-aliases als; then
            comptry "$als[@]"
          else
            comptry "$tag"
	  fi
        done
      else
        tmp2=()
	for tag; do
	  if zstyle -a ":completion:${curcontext}:${tag}" tag-aliases als; then
	    tmp2=( "$tmp2[@]" "$als[@]" )
          else
	    tmp2=( "$tmp2[@]" "$tag" )
	  fi
	done
        comptry "$tmp2[@]"
      fi
    fi
  fi

  # Return non-zero if at least one set of tags should be used.

  comptags "-T$prev"

  return
fi

# The other mode: switch to the next set of tags.

comptags "-N$prev"
