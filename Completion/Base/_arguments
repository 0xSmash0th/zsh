#autoload

# Complete the arguments of the current command according to the
# descriptions given as arguments to this function.

setopt localoptions extendedglob

local args rest ws cur nth def nm expl descr action opt arg tmp
local single uns ret=1 soptseq soptseq1 sopts prefix line
local beg optbeg argbeg nargbeg inopt inrest fromrest

# Associative arrays used to collect information about the options.

typeset -A opts dopts odopts
typeset -A oneshot

# Fill the cache if we were called with different arguments.

if [[ "$*" != "$_args_cache_descr" ]]; then
  _args_cache_descr="$*"

  unset _args_cache_{opts,dopts,odopts,oneshot}
  typeset -gA _args_cache_{opts,dopts,odopts,oneshot}

  unset _args_cache_{long,longcmd,single,rest,args,sopts,soptseq,soptseq1}

  # See if we are using single-letter options.

  if [[ "$1" = -s ]]; then
    shift
    _args_cache_single=yes
  fi

  # See if we support long options, too.

  nth=$argv[(I)--]
  if (( nth )); then
    local tmpargv

    if [[ nth -eq 1 ]]; then
      tmpargv=()
    else
      tmpargv=( "${(@)argv[1,nth-1]}" )
    fi

    tmp=${~words[1]}
    if [[ "$tmp" != /* ]]; then
      tmp="$PWD/$tmp"
    fi

    if [[ "$tmp" != "$_args_cache_longcmd" ]]; then
      local iopts pattern tmpo
      typeset -U lopts

      _args_cache_longcmd="$tmp"

      # We have to build the long-option cache anew, get the `-i' and
      # `-s' options.

      iopts=()
      sopts=()
      while [[ "$1" = -[is]* ]]; do
        if [[ "$1" = -??* ]]; then
	  tmp="${1[3,-1]}"
	  cur=1
        else
          tmp="$2"
	  cur=2
        fi
	if [[ "$tmp[1]" = '(' ]]; then
	  tmp=( ${=tmp[2,-2]} )
        else
	  tmp=( "${(@P)tmp}" )
        fi
	if [[ "$1" = -i* ]]; then
          iopts=( "$iopts[@]" "$tmp[@]" )
        else
          sopts=( "$sopts[@]" "$tmp[@]" )
        fi
	shift cur
      done

      # Now get the long option names by calling the command with `--help'.
      # The parameter expansion trickery first gets the lines as separate
      # array elements. Then we select all lines whose first non-blank
      # character is a hyphen. Since some commands document more than one
      # option per line, separated by commas, we convert commas int
      # newlines and then split the result again at newlines after joining 
      # the old array elements with newlines between them. Then we select
      # those elements that start with two hyphens, remove anything up to
      # those hyphens and anything from the space or comma after the
      # option up to the end. 

      lopts=("--${(@)^${(@)${(@)${(@M)${(@ps:\n:j:\n:)${(@)${(@M)${(@f)$(${~words[1]} --help 2>&1)//\[--/
--}:#[ 	]#-*}//,/
}}:#[ 	]#--*}#*--}%%[, ]*}:#}")

      # Now remove all ignored options ...

      while (( $#iopts )); do
        lopts=( ${lopts:#$~iopts[1]} )
        shift iopts
      done

      # ... and add "same" options

      while (( $#sopts )); do
        lopts=( $lopts ${opts/$sopts[1]/$sopts[2]} )
        shift 2 sopts
      done

      # Then we walk through the descriptions plus a few builtin ones.

      set -- "${(@)argv[nth+1,-1]}" '*=FILE*:file:_files' \
             '*=(DIR|PATH)*:directory:_files -/' '*:unknown:'

      while (( $# )); do

        # First, we get the pattern and the action to use and take them
        # from the positional parameters.

        pattern="${${${(M)1#*[^\\]:}[1,-2]}//\\\\:/:}"
        descr="${1#${pattern}}"
        shift

        # We get all options matching the pattern and take them from the
        # list we have built. If no option matches the pattern, we
        # continue with the next.

        tmp=("${(@M)lopts:##$~pattern}")
        lopts=("${(@)lopts:##$~pattern}")

        (( $#tmp )) || continue

        opt=''

        # If there are option strings with a `[=', we take these get an
        # optional argument.

        tmpo=("${(@M)tmp:#*\[\=*}")
        if (( $#tmpo )); then
          tmp=("${(@)tmp:#*\[\=*}")
          tmpo=("${(@)${(@)tmpo%%\=*}//[^a-z0-9-]}")

	  if [[ "$descr" = ::* ]]; then
	    _args_cache_long=( "$_args_cache_long[@]"
	                       "${(@)^tmpo}=${descr}" )
          else
	    _args_cache_long=( "$_args_cache_long[@]"
	                       "${(@)^tmpo}=:${descr}" )
          fi
        fi

	# Descriptions with `=': mandatory argument.

        tmpo=("${(@M)tmp:#*\=*}")
        if (( $#tmpo )); then
          tmp=("${(@)tmp:#*\=*}")
          tmpo=("${(@)${(@)tmpo%%\=*}//[^a-z0-9-]}")

	  if [[ "$descr" = ::* ]]; then
	    _args_cache_long=( "$_args_cache_long[@]"
	                       "${(@)^tmpo}=${descr[2,-1]}" )
          else
	    _args_cache_long=( "$_args_cache_long[@]"
	                       "${(@)^tmpo}=${descr}" )
          fi
        fi

	# Everything else is just added as a option without arguments.

        if (( $#tmp )); then
          tmp=("${(@)tmp//[^a-zA-Z0-9-]}")
	  _args_cache_long=( "$_args_cache_long[@]" "$tmp[@]" )
	fi
      done
    fi
    _args_cache_long=( "${(@)_args_cache_long:# #}" )

    set -- "$tmpargv[@]" "$_args_cache_long[@]"
  fi

  # Now parse the arguments...

  args=()
  nth=1
  while (( $# )); do

    # Description for both the `-foo' and `+foo' form?

    if [[ "$1" = (\*|)(-+|+-)* ]]; then

      # With a `*' at the beginning, the option may appear more than
      # once.

      if [[ "$1" = \** ]]; then
        tmp="${1[4,-1]%%:*}"
        [[ "$tmp" = *[-+] ]] && tmp="$tmp[1,-2]"
        unset "_args_cache_oneshot[-$tmp]" "_args_cache_oneshot[+$tmp]"
      else
        tmp="${1[3,-1]%%:*}"
        [[ "$tmp" = *[-+] ]] && tmp="$tmp[1,-2]"
        _args_cache_oneshot[-$tmp]=yes
        _args_cache_oneshot[+$tmp]=yes
      fi

      # If the option name ends in a `-', the first argument comes
      # directly after the option, if it ends in a `+', the first
      # argument *may* come directly after the option, otherwise it
      # is in the next word.

      if [[ "$1" = [^:]##-:* ]]; then
        _args_cache_dopts[-$tmp]="${1#*:}"
        _args_cache_dopts[+$tmp]="${1#*:}"
      elif [[ "$1" = [^:]##[+=]:* ]]; then
        _args_cache_odopts[-$tmp]="${1#*:}"
        _args_cache_odopts[+$tmp]="${1#*:}"
      elif [[ "$1" = *:* ]]; then
        _args_cache_opts[-$tmp]="${1#*:}"
        _args_cache_opts[+$tmp]="${1#*:}"
      else
        _args_cache_opts[-$tmp]=''
        _args_cache_opts[+$tmp]=''
      fi
    elif [[ "$1" = (\*|)[-+]* ]]; then

      # With a `*' at the beginning, the option may appear more than
      # once.

      if [[ "$1" = \** ]]; then
        tmp="${1[2,-1]%%:*}"
        [[ "$tmp" = *[-+] ]] && tmp="$tmp[1,-2]"
        unset "_args_cache_oneshot[$tmp]"
      else
        tmp="${1%%:*}"
        [[ "$tmp" = *[-+] ]] && tmp="$tmp[1,-2]"
        _args_cache_oneshot[$tmp]=yes
      fi

      # If the option name ends in a `-', the first argument comes
      # directly after the option, if it ends in a `+', the first
      # argument *may* come directly after the option, otherwise it
      # is in the next word.

      if [[ "$1" = [^:]##-:* ]]; then
        _args_cache_dopts[$tmp]="${1#*:}"
      elif [[ "$1" = [^:]##[+=]:* ]]; then
        _args_cache_odopts[$tmp]="${1#*:}"
      elif [[ "$1" = *:* ]]; then
        _args_cache_opts[$tmp]="${1#*:}"
      else
        _args_cache_opts[$tmp]=''
      fi
    elif [[ "$1" = \*::* ]]; then

      # This is `*:...', describing `all other arguments', with argument 
      # range restriction.

      if [[ "$1" = \*:::* ]]; then
        _args_cache_rest="*${1[3,-1]}"
      else
        _args_cache_rest="$1"
      fi
    elif [[ "$1" = \*:* ]]; then

      # This is `*:...', describing `all other arguments'.

      _args_cache_rest="${1[3,-1]}"
    elif [[ "$1" = :* ]]; then

      # This is `:...', describing `the next argument'.

      _args_cache_args[nth++]="${1#*:}"
    else

      # And this is `n:...', describing the `n'th argument.

      _args_cache_args[${1%%:*}]="${1#*:}"
      nth=$(( ${1%%:*} + 1 ))
    fi
    shift
  done

  if [[ -n "$_args_cache_single" ]]; then
    _args_cache_soptseq="${(@j::)${(@M)${(@k)_args_cache_opts[(R)]}:#[-+]?}#[-+]}"
    if [[ -n "$_args_cache_soptseq" ]]; then
      _args_cache_soptseq="[$_args_cache_soptseq]#"
      _args_cache_soptseq1="$_args_cache_soptseq#"
    else
      _args_cache_soptseq=''
      _args_cache_soptseq1=''
    fi
    _args_cache_sopts="${(@j::)${(@)${(@M)${=:-${(k)_args_cache_opts} ${(k)_args_cache_dopts} ${(k)_args_cache_odopts}}:#[-+]?(|=)}#?}%\=}"
  else
    _args_cache_soptseq=''
    _args_cache_soptseq1=''
    _args_cache_sopts=''
  fi
fi

soptseq="$_args_cache_soptseq"
soptseq1="$_args_cache_soptseq1"
sopts="$_args_cache_sopts"
args=( "$_args_cache_args[@]" )
rest="$_args_cache_rest"
opts=( "${(@kv)_args_cache_opts}" )
dopts=( "${(@kv)_args_cache_dopts}" )
odopts=( "${(@kv)_args_cache_odopts}" )
oneshot=( "${(@kv)_args_cache_oneshot}" )
single="$_args_cache_single"

# Parse the command line...

ws=( "${(@)words[2,-1]}" )
cur=$(( CURRENT-2 ))
nth=1
line=( "$words[1]" )
beg=2
argbeg=1
optbeg=1
nargbeg=1

# ...until the current word is reached.

while [[ cur -gt 0 ]]; do

  # `def' holds the description for the option we are currently after.
  # Check if the next argument for the option is optional.

  if [[ "$def" = :* ]]; then
    opt=yes
  else
    opt=''
  fi
  arg=''

  # See if we are after an option getting n arguments ended by something
  # that matches the current word.

  if [[ "$def" = \**[^\\]:* && "$ws[1]" = ${~${(M)def#*[^\\]:}[2,-2]} ]]; then
    def=''
    shift 1 ws
    (( cur-- ))
    (( beg++ ))
    continue
  fi

  # Remove one description/action pair from `def' if that isn't empty.

  if [[ -n "$def" && "$def" != \** ]]; then
    if [[ "$def" = ?*[^\\]:*[^\\]:* ]]; then
      def="${def#?*[^\\]:*[^\\]:}"
      argbeg="$beg"
    else
      def=''
    fi
  elif [[ -z "$def" ]]; then

    # Make sure we test for options below and handle normal arguments.

    opt=yes
    arg=yes
  fi

  if [[ -n "$opt" ]]; then

    # `opt' was set above if we have to test if the word is an option.
    # We first test for the simple options -- those without arguments or
    # those whose arguments have to be given as separate words.

    if (( $+opts[$ws[1]] )); then

      # Options that may only be given once are removed from the
      # associative array so that we don't offer them again.

      def="$opts[$ws[1]]"
      optbeg="$beg"
      argbeg="$beg"
      inopt=yes
      [[ -n "$oneshot[$ws[1]]" ]] && unset "opts[$ws[1]]"
    else
      uns=''
      if [[ -n "$sopts" && "$ws[1]" = [-+]${~soptseq}[$sopts] ]]; then
	tmp="${ws[1][1]}${ws[1][-1]}"
	if (( $+opts[$tmp] )); then
	  def="$opts[$tmp]"
	  optbeg="$beg"
	  argbeg="$beg"
          inopt=yes
	  uns="${ws[1][2,-1]}"
	  opt=''
	fi
      fi

      # If the word is none of the simple options, test for those
      # whose first argument has to or may come directly after the
      # option. This is done in two loops looking very much alike.

      if [[ -n "$opt" && $#dopts -ne 0 ]]; then

	# First we get the option names.

	tmp=( "${(@k)dopts}" )

	# Then we loop over them and see if the current word begins
	# with one of the option names.

	while (( $#tmp )); do
          if [[ -n "$sopts" && $tmp[1] = [-+]? ]]; then
	    if [[ "$ws[1]" = ${tmp[1][1]}${~soptseq}${tmp[1][2]}* ]]; then
	      uns="${ws[1][2,-1]%%${tmp[1][2]}*}${tmp[1][2]}"
	      break;
	    fi
	  elif [[ "$ws[1]" = ${tmp[1]}* ]]; then
            break
	  fi
	  shift 1 tmp
	done

	if (( $#tmp )); then

	  # It does. So use the description for it, but only from
	  # the second argument on, because we are searching the
	  # description for the next command line argument.

	  opt=''
	  def="$dopts[$tmp[1]]"
	  optbeg="$beg"
	  argbeg="$beg"
	  inopt=yes
	  [[ -n "$oneshot[$tmp[1]]" ]] && unset "dopts[$tmp[1]]"
	  if [[ "$def" = [^*]*[^\\]:*[^\\]:* ]]; then
            def="${def#?*[^\\]:*[^\\]:}"
          else
            def=''
	  fi
        fi
      fi
      if [[ -n "$opt" && $#odopts -ne 0 ]]; then
	tmp=( "${(@k)odopts%\=}" )
	while (( $#tmp )); do
          if [[ -n "$sopts" && $tmp[1] = [-+]? ]]; then
	    if [[ "$ws[1]" = ${tmp[1][1]}${~soptseq}${tmp[1][2]}* ]]; then
	      uns="${ws[1][2,-1]%%${tmp[1][2]}*}${tmp[1][2]}"
	      break;
	    fi
	  elif [[ "$ws[1]" = ${tmp[1]}* ]]; then
	    break
	  fi
	  shift 1 tmp
	done

	if (( $#tmp )); then
	  opt=''
	  def="$odopts[$tmp[1]]"
          [[ -z "$def" ]] && def="$odopts[$tmp[1]=]"
	  optbeg="$beg"
	  argbeg="$beg"
	  inopt=yes
	  [[ -n "$oneshot[$tmp[1]]" ]] && unset "odopts[$tmp[1]]"

	  # For options whose first argument *may* come after the
	  # option, we skip over the first description only if there
	  # is something after the option name on the line.

	  if [[ ( -z "$sopts" && ( "$def" = :* || "$ws[1]" != "$tmp[1]" ) ) ||
                ( -n "$sopts" && ( ( $tmp[1] = [-+]? && ( "$def" = :* || "$ws[1]" != "${tmp[1][1]}"${~soptseq}"${tmp[1][2]}" ) ) ||
		  		   ( $tmp[1] != [-+]? && ( "$def" = :* || "$ws[1]" != "$tmp[1]" ) ) ) ) ]]; then
	    if [[ "$def" = [^*]*[^\\]:*[^\\]:* ]]; then
              def="${def#?*[^\\]:*[^\\]:}"
	      optbeg="$beg"
	      argbeg="$beg"
            else
              def=''
            fi
	  fi
        fi
      fi

      [[ -n "$sopts" && -n "$opt" && "$ws[1]" = [-+]${~soptseq} ]] && \
          uns="${ws[1][2,-1]}"

      if [[ -n "$uns" ]]; then
	uns="${(j::)${(@k)oneshot[(I)${ws[1][1]}[$uns]]#[-+]}}"
	tmp=(
	  "opts[${(@)^opts[(I)${ws[1][1]}[$uns]]}]"
	  "dopts[${(@)^dopts[(I)${ws[1][1]}[$uns]]}]"
	  "odopts[${(@)^odopts[(I)${ws[1][1]}[$uns]]}]"
	)
	(( $#tmp )) && unset "$tmp[@]"
      fi

      # If we didn't find a matching option description and we were
      # told to use normal argument descriptions, just increase
      # our counter `nth'.

      if [[ -n "$opt" && -n "$arg" ]]; then
        def=''
	line=( "$line[@]" "$ws[1]" )
	[[ -n "$inopt" ]] && nargbeg=$(( beg - 1 ))
	inopt=''
        if [[ -z "$args[nth]" && "$rest" = \*::* ]]; then
	  inrest=yes
	  break
        fi
	(( nth++ ))
      fi
    fi
  fi

  shift 1 ws
  (( cur-- ))
  (( beg++ ))
done

[[ -n "$inopt" ]] && nargbeg=$(( beg - 1 ))

# Now generate the matches.

nm="$compstate[nmatches]"

if [[ -z "$def" || "$def" = :* ]]; then
  local pre="$PREFIX"

  uns=''

  # We either don't have a description for an argument of an option
  # or we have a description for a optional argument.

  opt=yes

  if [[ -z "$def" ]]; then

    # If we have none at all, use the one for this argument position.

    def="$args[nth]"
    if [[ -z "$def" ]]; then
      def="$rest"
      optbeg="$nargbeg"
      argbeg="$nargbeg"
      fromrest=yes
      [[ -n "$inrest" ]] && opt=''
    fi
  fi

  # In any case, we have to complete option names here, but we may
  # be in a string that starts with an option name and continues with
  # the first argument, test that (again, two loops).

  if [[ -n "$opt" && $#dopts -ne 0 ]]; then

    # Get the option names.

    tmp=( "${(@k)dopts}" )
    prefix="$PREFIX"
    while (( $#tmp )); do
      if [[ -n "$sopts" && $tmp[1] = [-+]? ]] && compset -P "${tmp[1][1]}${~soptseq}${tmp[1][2]}"; then
        def="$dopts[$tmp[1]]"
	opt=''
	uns="${prefix[2,-1]%%${tmp[1][2]}*}${tmp[1][2]}"
	break
      elif compset -P "$tmp[1]"; then

	# The current string starts with the option name, so ignore
	# that and complete the rest of the string.

	def="$dopts[$tmp[1]]"
	opt=''
	break
      fi
      shift 1 tmp
    done
  fi
  if [[ -n "$opt" && $#odopts -ne 0 ]]; then
    tmp=( "${(@k)odopts}" )
    prefix="$PREFIX"
    while (( $#tmp )); do
      if [[ -n "$sopts" && $tmp[1] = [-+]?(|=) ]] && compset -P "${tmp[1][1]}${~soptseq}${tmp[1][2]}${tmp[1][3]}"; then
        def="$odopts[$tmp[1]]"
	opt=''
	uns="${prefix[2,-1]%%${tmp[1][2]}*}${tmp[1][2]}"
	break
      elif compset -P "$tmp[1]"; then
	def="$odopts[$tmp[1]]"
	opt=''
	break
      fi
      shift 1 tmp
    done
  fi

  [[ -n "$sopts" && -n "$opt" && "$PREFIX" = [-+]${~soptseq}[$sopts] ]] && \
      uns="${PREFIX[2,-1]}"

  if [[ -n "$uns" ]]; then
    uns="${(j::)${(@k)oneshot[(I)${ws[1][1]}[$uns]]#[-+]}}"
    tmp=(
      "opts[${(@)^opts[(I)${pre[1]}[$uns]]}]"
      "dopts[${(@)^dopts[(I)${pre[1]}[$uns]]}]"
      "odopts[${(@)^odopts[(I)${pre[1]}[$uns](|=)]}]"
    )
    (( $#tmp )) && unset "$tmp[@]"
  fi

  # If we aren't in an argument directly after a option name, all option
  # names are possible matches.

  [[ -z "$opt" || ( "$def" = \** &&
                    ( -z "$fromrest" || CURRENT -ne argbeg+1 ) ) ]] && opt=''
else
  opt=''
fi

# Now add the matches from the description, if any.

while true; do

  if [[ -n "$def" ]]; then

    # Ignore the leading colon or `*...' describing optional arguments.

    if [[ "$def" = :* ]]; then
      def="$def[2,-1]"
    elif [[ "$def" = \** ]]; then
      tmp="${${(M)def#*[^\\]:}[2,-2]}"
      def="${def#*[^\\]:}"

      if [[ "$def" = :* ]]; then
        if [[ "$def" = ::* ]]; then
          def="$def[3,-1]"
	  beg=$argbeg
        else
	  def="$def[2,-1]"
	  beg=$optbeg
        fi

        [[ beg -ge $#words ]] && beg=$(( $#words - 1 ))

        shift beg words
        (( CURRENT -= beg ))

        if [[ -n "$tmp" ]]; then
          tmp="$words[(ib:CURRENT:)${~tmp}]"
	  [[ tmp -le $#words ]] && words=( "${(@)words[1,tmp-1]}" )
        fi
      fi
    fi

    # Get the description and the action.

    descr="${${${(M)def#*[^\\]:}[1,-2]}//\\\\:/:}"
    if [[ "$def" = *[^\\]:*[^\\]:* ]]; then
      action="${${${(M)${def#*[^\\]:}#*[^\\]:}[1,-2]}//\\\\:/:}"
    else
      action="${${def#*[^\\]:}//\\\\:/:}"
    fi

    _description expl "$descr"

    if [[ "$action" = \ # ]]; then

      # An empty action means that we should just display a message.

      _message "$descr"
      break

    elif [[ "$action" = \(\(*\)\) ]]; then

      # ((...)) contains literal strings with descriptions.

      eval ws\=\( "${action[3,-3]}" \)

      compadd -D ws - "${(@)ws%%:*}"

      if (( $#ws )); then
        beg=1
        for nth in "$ws[@]"; do
          tmp="${#nth%%:*}"
	  [[ tmp -gt beg ]] && beg="$tmp"
        done
        tmp=''
        for nth in "$ws[@]"; do
          tmp="$tmp
${(r:beg:: :)nth%%:*} -- ${nth#*:}"
        done
        tmp="$tmp[2,-1]"
        compadd "$expl[@]" -y tmp - "${(@)ws%%:*}"
      else
        _message "$descr"
      fi
    elif [[ "$action" = \(*\) ]]; then

      # Anything inside `(...)' is added directly.

      compadd "$expl[@]" - ${=action[2,-2]}
    elif [[ "$action" = \{*\} ]]; then

      # A string in braces is evaluated.

      eval "$action[2,-2]"

    elif [[ "$action" = \ * ]]; then

      # If the action starts with a space, we just call it.

      ${(e)=~action}
    else

      # Otherwise we call it with the description-arguments built above.

      action=( $=action )
      ${(e)action[1]} "$expl[@]" ${(e)~action[2,-1]}
    fi
  fi

  if [[ nm -eq compstate[nmatches] && $#_args_cache_long -ne 0 &&
        "$PREFIX" = --*=* ]]; then
    local suffix

    tmp=( "${(@Mk)odopts:#--[^:]#\=}" )
    prefix="${PREFIX#*\=}"
    suffix="$SUFFIX"
    PREFIX="${PREFIX%%\=*}"
    SUFFIX=''
    compadd -M 'r:|[_-]=* r:|=*' -D tmp - "${(@)tmp%\=}"

    if [[ $#tmp -eq 1 ]]; then
      def="$odopts[$tmp[1]]"
      PREFIX="$prefix"
      SUFFIX="$suffix"
      IPREFIX="$tmp[1]"
      continue
    fi
  fi
  break
done

# Probably add the option names.

if [[ -n "$opt" &&
      ( nm -eq compstate[nmatches] ||
        -z "$compconfig[option_prefix]" || "$PREFIX" = [-+]* ) ]]; then
  _description expl option
  if [[ -n "$sopts" && -n "$PREFIX" &&
    "$PREFIX" = [-+]${~soptseq}[$sopts] ]]; then
    if [[ "$PREFIX" = [-+]${~soptseq1} ]]; then
      compadd "$expl[@]" -Q -M 'r:|[_-]=* r:|=*' \
              -y "( ${(j: :)${(@)${(@M)${=:-${(k)opts} ${(k)dopts} ${(k)odopts}}:#[-+]?(|=)}#?}%=} )" - \
              "${PREFIX}${(@k)^opts[(I)${PREFIX[1]}?]#?}" \
	      "${PREFIX}${(@k)^dopts[(I)${PREFIX[1]}?]#?}" \
	      "${PREFIX}${(@)^${(@k)odopts[(I)${PREFIX[1]}?(|=)]#?}%=}" && ret=0
    else
      # The last option takes an argument in the next word.

      compadd "$expl[@]" -Q  -M 'r:|[_-]=* r:|=*' - "${PREFIX}" && ret=0
    fi
  else
    compadd "$expl[@]" -Q -M 'r:|[_-]=* r:|=*' - \
            "${(@k)opts}" "${(@k)odopts[(I)*[^=]]}" && ret=0
    compadd "$expl[@]" -Q -M 'r:|[_-]=* r:|=*' -qS= - \
            "${(@k)odopts[(I)*=]%=}" && ret=0
    compadd "$expl[@]" -QS '' -M 'r:|[_-]=* r:|=*' - "${(@k)dopts}" && ret=0
  fi
fi

# Set the return value.

[[ nm -ne "$compstate[nmatches]" ]]
