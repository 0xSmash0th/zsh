#compdef -K _history-complete-older complete-word \e/ _history-complete-newer complete-word \e,
#
# Complete words from the history
#
# by Adam Spiers, with help gratefully received from
# Sven Wischnowsky and Bart Schaefer
#
# Available styles:
#
#   list --  display lists of available matches
#   stop --  prevent looping at beginning and end of matches during
#            menu-completion
#   sort --  sort matches lexically (default is to sort by age)
#   remove-all-dups --
#            remove /all/ duplicate matches rather than just consecutives
#   range -- range of history words to complete

_history_complete_word () {
  setopt localoptions nullglob rcexpandparam extendedglob unset
  unsetopt markdirs globsubst shwordsplit shglob ksharrays cshnullglob

  local expl direction stop curcontext="$curcontext"
  local max slice hmax=$#historywords

  if [[ -z "$curcontext" ]]; then
    curcontext=history-words:::
  else
    curcontext="history-words${curcontext#*:}"
  fi

  if [[ $WIDGET = *newer ]]; then
    direction=newer
  else
    direction=older
  fi

  zstyle -s ":completion:${curcontext}:history-words" stop stop

  zstyle -t ":completion:${curcontext}:history-words" list || compstate[list]=''

  if zstyle -s ":completion:${curcontext}:history-words" range max; then
    if [[ $max = *:* ]]; then
      slice=${max#*:}
      max=${max%:*}
    else
      slice=$max
    fi
    [[ max -gt hmax ]] && max=$hmax
  else
    max=$hmax
    slice=$max
  fi

  if [[ -n "$compstate[old_list]" &&
        ( -n "$stop" || "$compstate[insert]" = menu ) ]] ; then
    # array of matches is newest -> oldest (reverse of history order)
    if [[ "$direction" == 'older' ]]; then
      if [[ compstate[old_insert] -eq $_hist_menu_length ||
            "$_hist_stop" == 'oldest' ]]; then
        _hist_stop='oldest'
        [[ "$stop" = verbose ]] &&
          _message 'beginning of history reached'
      elif [[ "$_hist_stop" == 'newest' ]]; then
        zle -Rc
        _history_complete_word_gen_matches
      else
        compstate[old_list]=keep
        (( compstate[insert] = compstate[old_insert] + 1 ))
      fi
    elif [[ "$direction" == 'newer' ]]; then
      if [[ compstate[old_insert] -eq 1 || "$_hist_stop" == 'newest' ]]; then
        _hist_stop='newest'
        [[ "$stop" = verbose ]] && _message 'end of history reached'
      elif [[ "$_hist_stop" == 'oldest' ]]; then
        zle -Rc
        _history_complete_word_gen_matches
      else
        compstate[old_list]=keep
        (( compstate[insert] = compstate[old_insert] - 1 ))
      fi
    fi
  else
    _hist_stop=''
    _hist_old_prefix="$PREFIX"
    _history_complete_word_gen_matches
  fi

  (( $compstate[nmatches] ))
}

_history_complete_word_gen_matches () {
  local opt beg=2

  [[ -n "$_hist_stop" ]] && PREFIX="$_hist_old_prefix"

  if zstyle -t ":completion:${curcontext}:history-words" remove-all-dups; then
    opt=-
  else
    opt=-1
  fi
  if zstyle -t ":completion:${curcontext}:history-words" sort; then
    opt="${opt}J"
  else
    opt="${opt}V"
  fi

  PREFIX="$IPREFIX$PREFIX"
  IPREFIX=
  SUFFIX="$SUFFIX$ISUFFIX"
  ISUFFIX=

  while [[ $compstate[nmatches] -eq 0 && beg -lt max ]]; do
    _main_complete - history _wanted "$opt" history-words expl 'history word' \
                                 compadd -Q -a 'historywords[beg,beg+slice]'
    (( beg+=slice ))
  done

  zstyle -t ":completion:${curcontext}:history-words" list ||
      compstate[list]=

  _hist_menu_length="$compstate[nmatches]"

  case "$direction" in 
    newer)  compstate[insert]=$_hist_menu_length
	    [[ -n "$_hist_stop" ]] && (( compstate[insert]-- ))
            ;;
    older)  compstate[insert]=1
	    [[ -n "$_hist_stop" ]] && (( compstate[insert]++ ))
            ;;
  esac

  [[ -n "$_hist_stop" ]] && _hist_stop=''
}

_history_complete_word "$@"
