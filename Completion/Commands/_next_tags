#compdef -k complete-word \C-xn

# Main widget.

_next_tags() {
  local comp ins

  if [[ -z $compstate[old_list] ]]; then
    comp=()
  else
    comp=(_complete)
  fi

  (( $+_sort_tags )) || _next_tags_not=

  _sort_tags=_next_tags_sort
  _next_tags_pre="${LBUFFER%${PREFIX}}"
  _next_tags_not="$_next_tags_not $_lastcomp[tags]"

  if [[ -n "$compstate[old_insert]" ]]; then
    PREFIX="$_lastcomp[prefix]"
    SUFFIX="$_lastcomp[suffix]"
    ins=1
  fi

  _main_complete "$comp[@]"

  [[ $compstate[insert] = automenu ]] &&
     compstate[insert]=automenu-unambiguous

  compstate[insert]="$ins"
  compstate[list]='list force'

  compprefuncs=( "$compprefuncs[@]" _next_tags_pre )
}

# Pre-completion function.

_next_tags_pre() {

  # Probably `remove' our sort function. A better test would be nice, but
  # I think one should still be able to edit the current word between
  # attempts to complete it.

  if [[ -n $compstate[old_insert] && $WIDGET != _next_tags ]]; then
    compstate[old_list]=keep
    compstate[insert]=menu:2
    return 0
  elif [[ ${LBUFFER%${PREFIX}} != ${_next_tags_pre}* ]]; then
    unset _sort_tags
  else
    compprefuncs=( "$compprefuncs[@]" _next_tags_pre )
    [[ -n "$compstate[old_list]" && -n "$_next_tags_reset" ]] &&
        _next_tags_not= _next_tags_reset=
  fi
}

# Helper function for sorting tags. Most of this is copied from _tags.

_next_tags_sort() {
  local order tags tag nodef tmp

  zstyle -a ":completion:${curcontext}:" tag-order order ||
      order=('arguments values' options)

  # But we also remove the tags we've already tried...

  tags=( "${(@)order:#(${(j:|:)~${=_next_tags_not}})(|:*)}" )

  # ... unless that would remove all offered tags.

  if [[ $funcstack[4] = _files ]]; then
    if zstyle -a ":completion:${curcontext}:" file-patterns tmp; then
      [[ "$tags" = *${${tmp[-1]##[^\\]:}%:*}* ]] &&
          tags=( $order ) _next_tags_reset=yes
    else
      [[ "$tags" = *all-files* ]] && tags=( $order ) _next_tags_reset=yes
    fi
  else
     [[ $#tags -ne $#order && "$tags" != *(${(j:|:)~argv})* ]] &&
        tags=( $order ) _next_tags_reset=yes
  fi
  for tag in $tags; do
    case $tag in
    -)     nodef=yes;;
    *\(\)) "${${tag%%[ 	]#\(\)}##[ 	]#}" "$@";;
    \!*)   comptry "${(@)argv:#(${(j:|:)~${=~tag[2,-1]}})}";;
    ?*)    comptry -m "$tag";;
    esac
  done

  if [[ -z "$nodef" ]]; then
    if [[ $funcstack[4] = _files ]]; then
      if zstyle -a ":completion:${curcontext}:" file-patterns tmp; then
        [[ "$argv" = *${${tmp[-1]##[^\\]:}%:*}* ]] && _next_tags_reset=yes
      else
        [[ "$argv" = *all-files* ]] && _next_tags_reset=yes
      fi
    fi
    comptry "${(@)argv:#(${(j:|:)~${=_next_tags_not}})(|:*)}"
  fi
}

[[ -o kshautoload ]] || _next_tags "$@"
