texinode(Arithmetic Evaluation)(Conditional Expressions)(Jobs & Signals)(Top)
chapter(Arithmetic Evaluation)
ifzman(\
sect(Arithmetic Evaluation)
)\
cindex(arithmetic evaluation)
cindex(evaluation, arithmetic)
findex(let, use of)
The shell can perform integer arithmetic, either using the builtin tt(let),
or via a substitution of the form tt($((...))).  The shell is usually
compiled to use 8-byte precision where this is available, otherwise
precision is 4 bytes.  This can be tested, for example, by giving the
command `tt(print - $(( 12345678901 )))'; if the number appears unchanged,
the precision is at least 8 bytes.

The tt(let) builtin command takes arithmetic expressions as arguments; each
is evaluated separately.  Since many of the arithmetic operators, as well
as spaces, require quoting, an alternative form is provided: for any
command which begins with a `tt(LPAR()LPAR())', all the characters until a
matching `tt(RPAR()RPAR())' are treated as a quoted expression and
arithmetic expansion performed as for an argument of tt(let).  More
precisely, `tt(LPAR()LPAR())var(...)tt(RPAR()RPAR())' is equivalent to
`tt(let ")var(...)tt(")'.  For example, the following statement

example((( val = 2 + 1 )))

is equivalent to

example(let "val = 2 + 1")

both assigning the value 3 to the shell variable tt(foo) and returning a
zero status.

cindex(bases, in arithmetic)
Numbers can be in bases other than 10.
A leading `tt(0x)' or `tt(0X)' denotes hexadecimal.
Numbers may also be of the form `var(base)tt(#)var(n)',
where var(base) is a decimal number between two and thirty-six
representing the arithmetic base and var(n)
is a number in that base (for example, `tt(16#ff)' is 255 in hexadecimal).
The var(base)tt(#) may also be omitted, in which case
base 10 is used.  For backwards compatibility the form
`tt([)var(base)tt(])var(n)' is also accepted.

cindex(arithmetic operators)
cindex(operators, arithmetic)
An arithmetic expression uses nearly the same syntax, precedence, and
associativity of expressions in C.
The following operators are supported (listed in decreasing order
of precedence):

startsitem()
sitem(tt(PLUS() - ! ~ PLUS()PLUS() --))(unary plus/minus, logical NOT, complement, {pre,post}{in,de}crement)
sitem(tt(<< >>))(bitwise shift left, right)
sitem(tt(&))(bitwise AND)
sitem(tt(^))(bitwise XOR)
sitem(tt(|))(bitwise OR)
sitem(tt(**))(exponentiation)
sitem(tt(* / %))(multiplication, division, modulus (remainder))
sitem(tt(PLUS() -))(addition, subtraction)
sitem(tt(< > <= >=))(comparison)
sitem(tt(== !=))(equality and inequality)
sitem(tt(&&))(logical AND)
sitem(tt(|| ^^))(logical OR, XOR)
sitem(tt(? :))(ternary operator)
sitem(tt(= PLUS()= -= *= /= %= &= ^= |= <<= >>= &&= ||= ^^= **=))(assignment)
sitem(tt(,))(comma operator)
endsitem()

The operators `tt(&&)', `tt(||)', `tt(&&=)', and `tt(||=)' are short-circuiting,
and only one of the latter two expressions in a ternary operator
is evaluated.  Note the precedence of the bitwise AND, OR,
and XOR operators.

An expression of the form `tt(#\)var(x)' where var(x) is any character
sequence such as `tt(a)', `tt(^A)', or `tt(\M-\C-x)' gives the ascii
value of this character and an expression of the form `tt(#)var(foo)'
gives the ascii value of the first character of the value of the
parameter var(foo).  Note that this is different from the expression
`tt($#)var(foo)', a standard parameter substitution which gives the
length of the parameter var(foo).

Named parameters and subscripted arrays can be referenced by name within an
arithmetic expression without using the parameter expansion syntax.  For
example,

example(((val2 = val1 * 2)))

assigns twice the value of tt($val1) to the parameter named tt(val2).

An internal integer representation of a named parameter
can be specified with the tt(integer) builtin.
cindex(parameters, integer)
cindex(integer parameters)
findex(integer, use of)
Arithmetic evaluation is performed on the value of each
assignment to a named parameter declared integer
in this manner.
