texinode(Completion System)(Zftp Function System)(Zsh Modules)(Top)
chapter(Completion System)
cindex(completion system)
cindex(completion, programmable)
cindex(completion, controlling)
sect(Description)

This describes the shell code for the new completion system.  It consists
of various shell functions; those beginning `tt(comp)' are to be called
directly by the user, while those beginning `tt(_)' are called by the
completion code.  The shell functions of the second set which implement
completion behaviour and which may be bound to keystrokes, are referred to
as `widgets'.

Note that with the function-based completions described here, it
is also possible to use the `tt(compctl -M ...)' mechanism to specify
global matching control, such as case-insensitivity (`tt(abc)' will complete
to a string beginning `tt(ABC)'), or wildcard behaviour on
certain anchors (`tt(a-d)' will complete to abc-def as if there were a
`tt(*)' after the `a').  See
ifzman(the section `Matching Control' in zmanref(zshcompctl))\
ifnzman(noderef(Matching Control))
for further details.

startmenu()
menu(Initialization)
menu(Control Functions)
menu(Completion Functions)
menu(Completion Directories)
menu(Bindable Commands)
menu(Completion System Configuration)
endmenu()

texinode(Initialization)(Control Functions)()(Completion System)
sect(Initialization)
findex(compinstall)
cindex(completion system, installing)

The function tt(compinstall) can be run by a user to set up the completion
system for use, which also provides options for more advanced usage.
However, if the system was installed completely, it should be enough to
call the shell function tt(compinit) from your initialization file; see the
next section.

Usually, tt(compinstall) will insert code into tt(.zshrc), although if
that is not writable it will save it in another file and tell you that
file's location.  Note that it is up to you to make sure that the lines
added to tt(.zshrc) are actually run; you may, for example, need to move
them to an earlier place in the file if tt(.zshrc) usually returns early.
So long as you keep them all together (including the comment lines at the
start and finish), you can rerun tt(compinstall) and it will correctly
locate and modify these lines.  Note, however, that any code you add to
this section by hand is likely to be lost if you rerun tt(compinstall).
The new code will take effect next time you start the shell, or run
tt(.zshrc) by hand.

To run it, you will need to make sure it is in a directory mentioned in your
tt($fpath) parameter, and that it is autoloaded (`tt(autoload -U
compinstall)' is recommended).  It will ask you various questions about how
you would like completion set up.  It is in two parts; the basic part
locates the completion files and decides where to put your personal
dumpfile, used to speed up initialization after the first time.  After
that, you will be asked if you wish to go on to the advanced set-up; if you
answer tt(n), you can rerun tt(compinstall) later without having to
re-enter any of the basic settings.

You can abort the installation any time you are being prompted for
information, and your tt(.zshrc) will not be altered at all.

After initialization all the builtin completion widgets such as
tt(expand-or-complete) will be redefined to use the new completion system.
Should you need to, you can still bind keys to the old functions by putting
a `tt(.)' in front, e.g. `tt(.expand-or-complete)'.

subsect(Use of compinit)
findex(compinit)
cindex(completion system, initializing)

This section describes the use of tt(compinit) to initialize completion for
the current session when run directly by the user; if you have run
tt(compinstall) it will be called automatically from your tt(.zshrc).

To initialize the system, the function tt(compinit) should be in a
directory mentioned in the tt($fpath) variable, and should be autoloaded
(`tt(autoload -U compinit)' is recommended).  When run, it will define a
few utility functions, arrange for all the necessary shell functions to be
autoloaded, and will then re-bind all keys that do completion to use the
new system.

To speed up the running of tt(compinit), it can be made to produce a dumped
configuration which will be read in on future invocations; this is the
default, although it can be turned off by calling tt(compinit) with the
option tt(-D).  The dumped file is tt(.zcompdump) in the same
directory as the startup files (i.e. tt($ZDOTDIR) or tt($HOME));
alternatively, an explicit file name can be given by `tt(compinit -d)
var(dumpfile)'.  On the next call to tt(compinit), the dumped file will be
read instead of a full initialization.

If the number of completion files changes, tt(compinit) will recognise this
and produce a new dump file.  However, if the name of a function or the
arguments in the first line of a tt(#compdef) function (as described below)
change, it is easiest to delete the dump file by hand so that the next time
tt(compinit) will re-create it.

The dumping is actually done by another function, tt(compdump), but you
will only need to run this yourself if you change the configuration
(e.g. using tt(compdef)) and then want to dump the new one.  The name of
the old dumped file will be remembered for this purpose.

If the parameter tt(_compdir) is set, tt(compinit) uses it as a directory
where completion functions can be found; this is only necessary if they are
not already in the function search path.

subsect(Autoloaded files)
cindex(completion system, autoloaded functions)

The convention for autoloaded functions used in completion is that they
start with an underscore; as already mentioned, the tt(fpath/FPATH)
parameter must contain the directory in which they are stored.  If tt(zsh)
was properly installed on your system, then tt(fpath/FPATH) automatically
contains the required directories.

For incomplete installations, if tt(compinit) does not find enough files
beginning with an underscore (fewer than twenty) in the search path, it
will try to find more by adding the directory tt(_compdir) to the search
path; if you have run tt(compinstall), this will be set automatically.
Furthermore, if the directory in question ends in the path segment
tt(Core), or has a subdirectory named tt(Core), tt(compinit) will add all
subdirectories of the directory where tt(Core) is to the path: this allows
the functions to be in the same format as in the tt(zsh) source
distribution.

When tt(compinit) is run, it searches all such files accessible via
tt(fpath/FPATH) and reads the first line of each of them.  This line should
contain one of the tags described below. Files whose first line does not
start with one of these tags are not considered to be part of the
completion system and will not be treated specially.

The tags are:

startitem()
item(tt(#compdef) var(names...))(
The file will be made autoloadable and the function defined 
in it will be called when completing var(names), each of which is
either the name of a command whose arguments are to be completed or one of
a number of special contexts in the form tt(-)var(context)tt(-) described
below for the tt(_complete) function.
)
item(tt(#compdef -p) var(pattern))(
The file will be made autoloadable and the function defined in it will be
called when completing for a command whose name matches the given
var(pattern) (a standard globbing pattern).  Note that only one
var(pattern) may be given.
)
item(tt(#compdef -P) var(pattern))(
Like the previous one, but the function will be called only if no
completion function for the command on the line could be found.
)
item(tt(#compdef -k) var(style key-sequences...))(
This can be used to bind special completion functions to the
var(key-sequences).  It creates a widget behaving like the builtin widget
var(style), which must be one of those that perform completion, namely
tt(complete-word), tt(delete-char-or-list), tt(expand-or-complete),
tt(expand-or-complete-prefix), tt(list-choices), tt(menu-complete),
tt(menu-expand-or-complete), or tt(reverse-menu-complete). If the
tt(complist) module is loaded (see
ifzman(zmanref(zshmodules))\
ifnzman(noderef(The complist Module))\
), the tt(menu-select) widget can be used, too.  If the option tt(-n) is
also given, the bindings will not be used if the key is already bound (that
is, is bound to something other than tt(undefined-key)).

The widget is then bound to all the var(key-sequences) given, if any: when
one of the var(key-sequences) is typed, the function in the file will
be invoked to generate the matches. The widget created has the same
name as the file and can also be bound to other keys using tt(bindkey) 
as usual.
)
item(tt(#autoload))(
This is used for files defining utility function that are not to be
called directly as completion functions but should be loaded automatically
when invoked.  Typically they are to be called from within one of the
completion functions.
)
enditem()

Note that the tt(#) is part of the tag name and no white space is allowed
after it.  The tt(#compdef) tags use the tt(compdef) function defined
below; the main difference is that the name of the function is supplied
implicitly.

subsect(Functions)

The tt(compinit) file defines the following functions, which may
also be called directly by the user.

findex(compdef)
cindex(completion system, adding definitions)
startitem()
xitem(tt(compdef) [ tt(-an) ] var(function names...))
xitem(tt(compdef -d) var(names...))
xitem(tt(compdef -p) [ tt(-a) ] var(function pattern))
xitem(tt(compdef -P) [ tt(-a) ] var(function pattern))
item(tt(compdef -k) [ tt(-a) ] var(function style key-sequences...))(
The first form tells the completion system to call the given
var(function) when completing for the contexts or commands
whose var(names) are given:  this is like the tt(#compdef) tag.  If the
tt(-n) option is given, any existing completion behaviour for particular
contexts or commands will not be altered.  These definitions can be deleted
by giving the tt(-d) option as in the second form.

The third form is similar to the first, but var(function) will be called
for all commands whose name matches the var(pattern); this is like the
tt(#compdef -p) function tag.

The fourth form is like the third, but the var(function) will be
called only if no function for the command itself was found or if one
was found and it set the tt(_compskip) parameter to a value em(not)
containing the substring `tt(patterns)'.

The fifth form defines a widget with the same name as the var(function)
which will be called for each of the var(key-sequences); this is like the
tt(#compdef -k) tag.  The function should generate the completions needed
and will otherwise behave like the builtin widget whose name is given as
the var(style) argument. The widgets usable for this are:
tt(complete-word), tt(delete-char-or-list), tt(expand-or-complete),
tt(expand-or-complete-prefix), tt(list-choices), tt(menu-complete),
tt(menu-expand-or-complete), and tt(reverse-menu-complete), as well as
tt(menu-select) if the tt(complist) module is loaded.  The option tt(-n)
prevents the key being bound if it is already to bound to something other
than tt(undefined-key).

In each of the forms supporting it the tt(-a) option makes the
var(function) autoloadable (exactly equivalent to
tt(autoload )var(function)).
)
findex(compconf)
cindex(completion system, configuring)
xitem(tt(compconf) var(definitions...))
xitem(tt(compconf) [ tt(-L) ] )
item(tt(compconf) [ tt(-l) ] [ tt(-L) ] var(keys...))(
vindex(compconfig)
Several aspects of the completion system can be configured by the
user. The configuration values are stored under the keys described
below in the associative array `tt(compconfig)'.  After sourcing
tt(compinit), configuration values can either be set directly as in
`tt(compconfig[completer]=_complete)' or by calling this utility function.

Each var(definition) may be either a simple `var(key)', which sets this
key in the tt(compconfig) array to an empty string, or of the form
`var(key=value)' which stores the `var(value)' under key `var(key)'.

Since the completion system also uses the array for internal purposes,
you should not set all values at once by doing `tt(compconfig=(...))'.

In the second form (without arguments), this function lists all keys
and their values. If given the tt(-l) option as its first argument, as 
in the last form, the other arguments are taken as names of keys and
the values of these keys are printed one per line. In either case, if the
tt(-L) option is given, the keys and values are printed as calls to this
function, usable to be put in a setup script.
)
findex(funcall)
item(tt(funcall) var(return) var(name) [ var(args) ... ])(
If a function var(name) exists, it is called with the arguments
var(args). Unless it is the empty string or a single hyphen,
var(return) is taken as the name of a parameter and the return status
from the called function is stored in it.
The return value of tt(funcall) itself is zero if the function
var(name) exists and was called and non-zero otherwise.
)
enditem()

texinode(Control Functions)(Completion Functions)(Initialization)(Completion System)
sect(Control Functions)
cindex(completion system, choosing completers)

The initialization script tt(compinit) redefines all the widgets
which perform completion to call the supplied widget
function tt(_main_complete). This function acts as a wrapper calling
the so-called `completer' functions that generate matches. If
tt(_main_complete) is
called with arguments, these are taken as the names of completer
functions to be called in the order given.  If no arguments are given, the
set of functions to try is taken from the colon-separated list in the
configuration key tt(completer). For example, to use normal
completion and correction if that doesn't generate any matches:

example(compconf completer=_complete:_correct)

after sourcing tt(compinit). The default value for this configuration key
set up in tt(compinit) is `tt(_complete)', i.e. normally only ordinary
completion is tried. The tt(_main_complete) function uses the return value
of the completer functions to decide if other completers should be
called. If the return value is zero, no other completers are tried and the
tt(_main_complete) function returns.

The widget function tt(_main_complete) also uses the configuration key 
tt(last_prompt). If this is set to tt(always), the cursor is moved up
to the last prompt after printing a list of matches even if a numeric
argument was given.

The following completer functions are contained in the distribution (users
may write their own):

cindex(completion system, completers)
startitem()
item(tt(_complete))(
This completer generates all possible completions in a context-sensitive
manner, i.e. using the tt(compdef) function
explained above and the current settings of all special parameters.

To complete arguments of commands, tt(_complete) uses the utility function
tt(_normal), which is in turn responsible for finding the particular
function; it is described below.  Various contexts of the form
tt(-)var(context)tt(-), as mentioned above for the tt(#compdef) tag, are
handled specially.  These are:

startitem()
item(tt(-equal-))(
for completion after an equal sign, other than one occurring in a
shell-variable assignment.
)
item(tt(-tilde-))(
for completion after a tilde (`tt(~)') character, but before a slash.
)
item(tt(-redirect-))(
for completion after a redirection operator.
)
item(tt(-math-))(
for completion inside mathematical contexts, such as
`tt(LPAR()LPAR())...tt(RPAR()RPAR())'.
)
item(tt(-subscript-))(
for completion inside subscripts.
)
item(tt(-value-))(
for completion on the right hand side of an assignment.
)
item(tt(-array-value-))(
for completion on the right hand side of an array-assignment
(`tt(foo=LPAR()...RPAR())').
)
item(tt(-condition-))(
for completion inside conditions (`tt([[...]])').
)
item(tt(-parameter-))(
for completing the name of a parameter expansion (`tt($...)').
)
item(tt(-brace-parameter-))(
for completing the name of a parameter expansion within braces
(`tt(${...})').
)
item(tt(-first-))(
for adding completions before any other other completion functions are
tried (similar to the `tt(-T)' flag of tt(compctl)); if this
function sets the tt(_compskip) parameter to `tt(all)', no other
completion functions will be called, if it is set to a string
containing `tt(patterns)', no pattern completion functions will be
called, and if it is set to a string containing `tt(default)' the
function for the `tt(-default-)' context will not be called, but
functions defined for commands will.
)
item(tt(-default-))(
for generating completions when no special completion function is used 
(similar to the `tt(-D)' option of tt(compctl)).
)
item(tt(-command-))(
for completing in a command position (as with the `tt(-C)' option of
tt(compctl)).
)
enditem()

Default implementations are supplied for each of these
contexts, in most cases named after the context itself
(e.g. completion for the `tt(-tilde-)' context is done by the function 
named `tt(_tilde)').

Before trying to find a function for a specific context, tt(_complete) 
checks if the parameter `tt(compcontext)' is set to a non-empty
value. If it is, the value is taken as the name of the context to use
and the function defined for that context will be called.
)
item(tt(_approximate))(
This completer function uses the tt(_complete) completer to generate
a list of strings for the context the cursor is currently in, allowing 
you to specify a maximum number of errors:  see the description of
approximate matching in
ifzman(\
zmanref(zshexpn)
)\
ifnzman(\
noderef(Filename Generation)
)\
for how errors are
counted. The resulting list of corrected and completed strings is then
presented to the user. The intended use of this completer function is to
try after the normal tt(_complete) completer by setting:

example(compconf completer=_complete:_approximate)

This will give correcting completion if and only if
normal completion doesn't yield any possible completions. When
corrected completions are found, the completer will normally start
menucompletion allowing you to cycle through these strings.

The exact behavior of this completer can be changed by using the
configuration keys tt(approximate_accept), tt(approximate_original),
tt(approximate_prompt), and tt(approximate_insert), see
ifzman(the section `Completion System Configuration' below)\
ifnzman(noderef(Completion System Configuration)).

If any of these keys is not set, but the the same key with the prefix
`tt(correct)' instead of `tt(approximate)' is set, that value will be
used. The forms beginning with `tt(correct)' are also used by the
tt(_correct) completer function.

The keys with the `tt(approximate)' prefix have no default values, but 
tt(compinit) defines default values for tt(correct_accept) (which 
is set to `tt(2n)'), and tt(correct_prompt).
)
item(tt(_correct))(
Generate corrections (but not completions) for the current word; this is
similar to spell-checking.  This calls tt(_approximate), but only the
configuration parameters beginning tt(correct_) are used.

For example, with:

example(compconf completer=_complete:_correct:_approximate
compconf correct_accept='2n!' approximate_accept=3n)

correction will accept up to two errors. If a numeric argument is
given, correction will not be performed, but correcting completion will be,
and will accept as many errors as given by the numeric argument.
Without a numeric argument, first correction and then correcting
completion will be tried, with the first one accepting two errors 
and the second one accepting three errors.

This completer function is intended to be used without the
tt(_approximate) completer or, as in the example, just before
it. Using it after the tt(_approximate) completer is useless since
tt(_approximate) will at least generate the corrected strings
generated by the tt(_correct) completer -- and probably more.
)
item(tt(_match))(
This completer is intended to be used after the tt(_complete)
completer. It allows one to give patterns on the command line and
to complete all strings matching these patterns from the set of possible
completions for the context the cursor is in, without having to set
the tt(GLOB_COMPLETE) option.

Normally this will be done by taking the pattern from the line,
inserting a `tt(*)' at the cursor position and comparing the resulting
pattern with the possible completions generated. However, if the
configuration key tt(match_original) has a value of `tt(only)', no
`tt(*)' will be inserted. If tt(match_original) has any other non-empty
string as its value, this completer will first try to generate matches
without, then with a `tt(*)' inserted at the cursor position.

The generated matches will be offered in a menucompletion unless the
tt(match_insert) configuration key is set to a string starting with
`tt(unambig)'. In this case menucompletion will only be started if no
unambiguous string could be generated that is at least as long as the
original string.
)
item(tt(_expand))(
This completer function does not really do completion, but instead
checks if the word on the command line is eligible for expansion and,
if it is, gives detailed control over how this expansion is done. When 
using this, one should not use the tt(expand-or-complete) widget, but
instead use tt(complete-word), as otherwise tt(expand-or-complete)
will expand the string on the line before the completion widget is
called. Also, this completer should be called before the tt(_complete) 
completer function.

Control over how the expanded string will be treated is possible with the 
configuration keys tt(expand_substitute), tt(expand_glob),
tt(expand_menu), tt(expand_original), and tt(expand_prompt), see
ifzman(the section `Completion System Configuration' below)\
ifnzman(noderef(Completion System Configuration)).

None of these configuration keys has a default value.
)
item(tt(_list))(
This completer allows one to delay the insertion of matches until
completion is attempted a second time without the word on the line
being changed. On the first attempt, only the list of matches will be
shown. Configuration keys understood are tt(list_condition) and
tt(list_word), see
ifzman(the section `Completion System Configuration' below)\
ifnzman(noderef(Completion System Configuration)).
)
item(tt(_menu))(
This completer is a simple example function implemented to show how
menucompletion can be done in shell code. It should be used as the
first completer and has the effect of making the code perform
menucompletion. Note that this is independent of the setting of the
tt(MENU_COMPLETE) option and does not work with the other
menucompletion widgets such as tt(reverse-menu-complete), or
tt(accept-and-menu-complete).
)
item(tt(_oldlist))(
This completer controls how the standard completion widgets behave when
there is an existing list of completions which may have been generated by a
special completion (i.e. a separately-bound completion command).  It should
appear in the list of completers before any of the widgets which generate
matches.  It understands two configuration keys: tt(oldlist_list) and
tt(oldlist_menu), see
ifzman(the section `Completion System Configuration' below)\
ifnzman(noderef(Completion System Configuration)).
)
enditem()

texinode(Completion Functions)(Completion Directories)(Control Functions)(Completion System)
sect(Utility Functions)
cindex(completion system, utility functions)

Descriptions follow for utility functions that may be
useful when writing completion functions.  Most of these reside in the
tt(Core) subdirectory except where noted. Like the example 
functions for commands in the distribution, the utility functions
generating matches all follow the convention of returning zero if they
generated completions and non-zero if no matching completions could be 
added.

startitem()
item(tt(_compalso))(
This function looks up the definitions for the context and command
names given as arguments and calls the handler functions for them if
there is a definition (given with the tt(compdef) function). For
example, the function completing inside subscripts might use
`tt(_compalso -math-)' to include the completions generated for
mathematical environments.
)
item(tt(_normal))(
This function is used for normal command completion.  If
completion is attempted on the first word, command names are
completed. Otherwise, the arguments are completed by calling the
functions defined for this command, including those functions defined
for patterns matching the command name. This function can also be
called by other completion functions if they have to complete a range
of words as a separate command. For example, the function to complete after
the pre-command specifiers such as tt(nohup) removes the first word from
the tt(words) array, decrements the tt(CURRENT) parameter, then calls this
function.

When calling a function defined for a pattern, this function also
checks if the parameter tt(_compskip) is set and uses the value in the 
same way it is used after calling the completion function for the
tt(-first-) context. With this 
one can write a pattern completion function that keeps other functions 
from being tried simply by setting this parameter to any value.
)
item(tt(_description))(
This function gets two arguments: the name of an array and a
string. It tests if the configuration key tt(description_format) is
set and if it is, it stores some options in the array that can then be 
given to the tt(compadd) and tt(compgen) builtin commands to make the
value of the tt(description_format) key (with the sequence `tt(%d)'
replaced by the string given as the second argument) be displayed
above the matches added. These options also will make sure that the
matches are placed in a separate group (the second argument is used as 
the name of the group) if the configuration key tt(group_matches) is
set to a non-empty string. Normally a sorted group will be used for this
(with the `tt(-J)' option), but if the option `tt(-V)' is given, a
unsorted group will be used instead.

In most cases, this function will be used like this:

example(local expl
_description expl file
compadd "$expl[@]" - "$files[@]")
)
item(tt(_message))(
This function takes one argument which is used like the second
argument to the tt(_description) function. However, the resulting
string will always be shown, not only if some matches were
generated. This is useful to display help texts in places where no
completions can be generated automatically.

This function also uses the configuration key tt(message_format) in
preference to tt(description_format). The latter is used only if the
former is unset or set to the empty string.
)
item(tt(_display))(
This function generates a display list usable for the `tt(-d)' option
of tt(compadd). For this it takes its arguments except the first one
as possible matches with descriptions. The strings should contain the
match, optionally followed by a colon and the description for this
match. From this tt(_display) builds an array with elements containing 
the matches and their descriptions, where the descriptions are aligned.
After that, the first argument is taken as a parameter name and the
array built is stored in it.

The return value of tt(_display) is zero if there was at least one
match with a description non-zero otherwise.
)
item(tt(_describe))(
This function can be used to add options or values with descriptions
as matches. The first argument is taken as a string to display above
the matches if the tt(description_format) configuration key is set.

After this one or two names of arrays followed by options to give
to tt(compadd) must be given. The first array contains the possible
completions with their descriptions (with the description separated
by a colon from the completion string). If the second array is given,
it should have the same number of elements as the first one and these
elements are added as possible completions instead of the strings from 
the first array. In any case, however, the completion list will show
the strings from the first array.

Any number of array/option sequences may be given separated by
`tt(-)tt(-)'. This allows one to display matches together that need
to be added with different options for tt(compadd).

Before the first argument, two options may be given. A `tt(-o)' says
that the matches added are option names. This will make tt(_describe)
use the tt(option_prefix) and tt(describe_options) configuration keys
to find out if the strings should be added at all and if the
descriptions should be shown. Without the `tt(-o)' option, the
tt(describe_values) key is used.

The `tt(-c)' option, followed by a string, may be used to give the
name of the current command for testing the configuration keys. If the 
first element of the tt(words) special array contains the correct
command name, this option need not be used.
)
item(tt(_multi_parts))(
This function gets two arguments: a separator character and an
array.  As usual, the array may be either the
name of an array parameter or a literal array in the form
`tt(LPAR()foo bar)tt(RPAR())' (i.e. a list of words separated by white 
space in parentheses). With these arguments, this function will
complete to strings from the array where the parts separated by the
separator character are completed independently. For example, the
tt(_tar) function from the distribution caches the pathnames from the
tar file in an array and then calls this function to complete these
names in the way normal filenames are completed by the
tt(_path_files) function.

Like other utility functions, this function accepts the `tt(-V)',
`tt(-J)', and `tt(-X)' options with an argument and passes them to the
tt(compadd) builtin.
)
item(tt(_sep_parts))(
This function gets as arguments alternating arrays and separators.
The arrays specify completions for parts of strings to be separated by the
separators. The arrays may be the names of array parameters or
a quoted list of words in parentheses. For example, with the array
`tt(hosts=(ftp news))' the call `tt(_sep_parts '(foo bar)' @ hosts)' will
complete the string  `tt(f)' to `tt(foo)' and the string `tt(b@n)' to
`tt(bar@news)'.

This function passes the `tt(-V)', `tt(-J)', and `tt(-X)' options and
their arguments to the tt(compadd) builtin used to add the matches.
)
item(tt(_path_files) and tt(_files))(
The function tt(_path_files) is used throughout the shell code
to complete filenames. The advantage over the builtin
completion functions is that it allows completion of partial paths. For
example, the string `tt(/u/i/s/sig)' may be completed to
`tt(/usr/include/sys/signal.h)'.  The options `tt(-/)', `tt(-f)', `tt(-g)',
and `tt(-W)' are available as for the tt(compctl)
and tt(compgen) builtins; tt(-f) is the default. Additionally, the `tt(-F)'
option from the tt(compadd) builtin is supported, giving direct control
over which filenames should be ignored as done by the tt(fignore)
parameter in normal completion.

The function tt(_files) calls tt(_path_files) with all the arguments
it was passed and, if that generated no matches, calls tt(_path_files) again
without any tt(-g) or tt(-/) option, thus generating all filenames.

These functions also accept the `tt(-J)', `tt(-V)', `tt(-X)', `tt(-P)',
`tt(-S)', `tt(-q)', `tt(-r)', and `tt(-R)' options from the
tt(compadd) builtin.

Finally, the tt(_path_files) function supports two configuration keys.
startitem()
item(tt(path_expand))(
If this is set to any non-empty string, the partially
typed path from the line will be expanded as far as possible even if
trailing pathname components can not be completed.
)
item(tt(path_cursor))(
If this is set to a non-empty string, the cursor will be left
after the first ambiguous pathname component even when menucompletion
is used.
)
enditem()
)
item(tt(_parameters))(
This should be used to complete parameter names if you need some of the
extra options of tt(compadd). All arguments are passed unchanged to
the tt(compadd) builtin.
)
item(tt(_options))(
This can be used to complete option names. The difference to the
`tt(-o)' option of tt(compgen) is that this function uses a matching
specification that ignores a leading `tt(no)', ignores underscores and 
allows the user to type upper-case letters, making them match their
lower-case counterparts. All arguments passed to this function are
propagated unchanged to the tt(compgen) builtin.
)
item(tt(_set_options) and tt(_unset_options))(
These functions complete only set or unset options, with the same
matching specification used in the tt(_options) function.

Note that you need to uncomment a few lines in the tt(_main_complete)
function for these functions to work properly. The lines in question
are used to store the option settings in effect before the completion
widget locally sets the options it needs.
)
item(tt(_arguments))(
This function resides in the tt(Base) subdirectory of the example
completion system because it is not used by the core system.

This function can be used to complete words on the line by simply
describing the arguments the command on the line gets. The description 
is given as arguments to this function, with each argument describing
one option or normal argument of the command. The descriptions
understood are:

startitem()
item(var(n)tt(:)var(message)tt(:)var(action))(
This describes the var(n)'th normal argument. The var(message) will be 
printed above the matches generated and the var(action) says what can
be completed in this position (see below).
)
item(tt(:)var(message)tt(:)var(action))(
Like the previous one, but describing the em(next) argument. I.e. if
you want to describe all arguments a command can get, you can leave
out the numbers in the description and just use this form to describe
them one after another in the order they have to appear on the line.
)
item(tt(*:)var(message)tt(:)var(action))(
This describes how arguments are to be completed for which no
description with one of the first two forms was given. This also means 
that any number of arguments can be completed.

If there are two colons before the message (as in
`tt(*::)var(message)tt(:)var(action)') the tt(words) special array and 
the tt(CURRENT) special parameter will be restricted to only the
normal arguments when the var(action) is executed or evaluated.
)
item(var(opt-spec)[var(description) ...])(
This describes an option and (if at least one var(description) is
given) the arguments that have to come after the option. If no
var(description) is given, this will only be used to offer the option
name as a possible completion in the right places. Each
var(description) has to be of the form
`tt(:)var(message)tt(:)var(action)' or
`tt(::)var(message)tt(:)var(action)', where the second form describes
an optional argument and the first one describes a mandatory argument.
The last description may also be of the form
`tt(:*:)var(message)tt(:)var(action)' or
`tt(:*)var(pattern)tt(:)var(message)tt(:)var(action)'. These describe
multiple arguments. In the first form all following words on the line
are to be completed as described by the var(action), in the second
form all words up to a word matching the given var(pattern) are to be
completed using the var(action). The `tt(*)' or the var(pattern) may
also be separated from the var(message) by two or three colons. With
two colons the tt(words) special array and the tt(CURRENT) special
parameter are modified to refer only to the words after the option
(with two colons) or to the words covered by this description (with
three colons) during the execution or evaluation of the var(action).

In the simplest form the var(opt-spec) is just the option name
beginning with a minus or a plus sign, such as `tt(-foo)'. In this
case, the first argument for the option (if any) has to come as a
separate word directly after the option and the option may appear only 
once on the line (and if it is already on the line, the option name
will not be offered as a possible completion again). If the first
argument for the option has to come directly after the option name
em(in the same word), a minus sign should be added to the end of the
var(opt-spec), as in `tt(-foo-)'. If the first argument may be given
in one string with the option name, but may also be given as a
separate argument after the option, a plus sign should be used
instead. If the argument may be given as the next string or in same
string as the option name but separated by it from an equal sign, a
`tt(=)' should be used instead of the minus or plus sign.

If the option may be given more than once, a star
(`tt(*)') has to be added in front of the var(opt-spec) because
otherwise it is not offered as a possible completion again if it is
already on the line.

An var(opt-spec) may also contain a list of other option names with
which the option described is mutually exclusive. Such a list is given 
in parentheses at the beginning, as in `tt((-two -three)-one:...)'. In 
this example, the options `tt(-two)' and `tt(-three)' will not be
offered as possible completions if the option `tt(-one)' is on the
line. Also, the list may contain a single colon as one of its elements 
to specify that the descriptions for normal (non-option-) arguments
should not be used if the option described is on the line.

Finally, the var(opt-spec) may contain a explanation string. This is
given in brackets at the end, as in `tt(-q[query operation])'. The
configuration key tt(describe_options) is used to decide if these
explanation strings should be printed when options are listed. If it
is set to a non-empty string and it doesn't contain the substring
`tt(!)var(command)', where `var(command)' is the name of the command
that is completed for, the descriptions will be shown.
)
enditem()

In each of the cases above, the var(action) says how the possible
completions should be generated. In cases where only one of a fixed
set of strings can be completed, these string can directly be given as 
a list in parentheses, as in `tt(:foo:(foo bar baz))'. Such a list in
doubled parentheses, as in `tt(:foo:((a\:bar b\:baz)))' should contain 
strings consisting of the string to complete followed by a colon
(which needs to be preceded by a backslash) and a description. The
matches will be listed together with their descriptions if the
value of configuration key tt(describe_values) is non-empty and does
not contain the substring `tt(!)var(command)', where `var(command)' is 
the name of the command on the line.

An var(action) of the form `tt(->)var(string)' is used by functions
that implement a state machine. In this case, the `var(string)' (with
all leading and trailing spaces and tabs removed) will be stored in
the global parameter tt(state) and the function returns with a return
value of 300 (to make it distinguishable from other return values)
after setting the global `tt(line)' and `tt(options)'
parameters as described below and without resetting any changes made
to the special parameters such as tt(PREFIX) and tt(words).

A string in
braces will be evaluated to generate the matches and if the
var(action) does not begin with an opening parentheses or brace, it
will be split into separate words and executed. If the var(action)
starts with a space, this list of words will be invoked unchanged,
otherwise it will be invoked with some extra string placed after the
first word which can be given as arguments to the tt(compadd) and
tt(compgen) builtins and which make sure that the var(message) given
in the description will be shown above the matches. These arguments
are taken from the array parameter tt(expl) which will be set up
before executing the var(action) and hence may be used in it (normally 
in an expansion like `tt($expl[@])').

In places where no sensible matches can be generated, the action
should consist of only a space. This will make the var(message) be
displayed but no possible completions listed.

To include a colon in the var(message) or the var(action), it has to
be preceded by a backslash.

During the evaluation or execution of the action the array `tt(line)'
will be set to the command name and normal arguments from the command
line, i.e. to the words from the command line excluding all options
and their arguments. These are stored in the associative array
`tt(options)', using the option names as keys and their arguments as
the values. For options that have more than one argument these are
given as one string, separated by colons. All colons in the original
arguments are preceded with backslashes.

Normally the option names are taken as multi-character names and a
word from the line is considered to contain only one option (or
none). By giving the tt(-s) option to this function (as the first
argument), options are considered to be one-character options and the
strings from the line may contain more than one such option
letter. However, strings beginning with two hyphens (like
`tt(-)tt(-prefix)') are still considered to contain only one option
name. This allows the use of the `tt(-s)' option to describe
single-letter options together with such long option names.

The function can also be made to automatically complete long options
for commands that support the `tt(-)tt(-help)' option as, for example,
most of the GNU commands do. For this, the string `tt(-)tt(-)' must be
given as one argument and if it is, the command from the line is
invoked with the `tt(-)tt(-help)' option and its output is parsed to find
possible option names. Note that this means that you should be careful
to make sure that this feature is not used for a command that does not
support this option.

For options that get an argument after a `tt(=)', the function also tries
to automatically find out what should be completed as the argument.
The possible completions for option-arguments can be described with
the arguments after the `tt(-)tt(-)' (which are not used as described
above). Each argument contains one description of the form
`var(pattern)tt(:)var(message)tt(:)var(action)'. The var(message) and
the var(action) have the same format as for the normal option
descriptions described above. The var(action) will be executed to
complete arguments of options whose description in the output of the
command from the line with the `tt(-)tt(-help)' option matches the
var(pattern). For example:

example(_arguments -- '*\*'     '(yes no)' \ 
              '*=FILE*' '_files' \ 
              '*=DIR*'  '_files -/')

Here, `tt(yes)' and `tt(no)' will be completed as the argument of
options whose description ends in a star, file names for options that
contain the substring `tt(=FILE)' in the description, and paths for
options whose description contains `tt(=DIR)'. In fact, the last two
patterns are not needed since this function always completes files
for option descriptions containing `tt(=FILE)' and paths for option
descriptions that contain `tt(=DIR)' or `tt(=PATH)'. These builtin
patterns can be overridden by patterns given as arguments, however.

Note also that tt(_arguments) tries to find out automatically if the
argument for an option is optional. If it fails to automatically
detect this, the colon before the var(message) can be doubled to tell
it about this as described for the normal option descriptions above.

The option `tt(-i) var(patterns)' (which must be given after the
`tt(-)tt(-)') can be used to give patterns for options which should not be
completed. The patterns can be given as the name of an array parameter
or as a literal list in parentheses. E.g. `tt(-i
"LPAR()-)tt(-(en|dis)able-FEATURE*RPAR()")' will make the options
`tt(-)tt(-enable-FEATURE)' and `tt(-)tt(-disable-FEATURE)' be ignored. The
option `tt(-s) var(pairs)' (again, after the `tt(-)tt(-)') can be used to
describe option aliases. Each var(pair) consists of a pattern and a
replacement. E.g. some tt(configure)-scripts describe options only as
`tt(-)tt(-enable-foo)', but also accept `tt(disable-foo)'. To allow
completion of the second form, one would use `tt(-s "LPAR()#-)tt(-enable-
-)tt(-disable-RPAR()")'.

Finally, this function uses the configuration key tt(option_prefix). If
it is set to a non-empty string, option names are added as possible
matches only if the word on the line begins with the prefix character
of them (i.e. a minus or a plus sign). If the value contains
`tt(!)var(command)' as a substring, where `var(command)' is the name
of the command that is completed for, the options are added as
possible matches even if their prefix character is not given on the
line.

Example:

example(_arguments '-l+:left border:' \
           '-format:paper size:(letter A4)' \
	   '*-copy:output file:_files::resolution:(300 600)' \
	   ':postscript file:_files -g *.(ps|eps)' \
	   '*:page number:')

This describes three options `tt(-l)', `tt(-format)', and
`tt(-copy)'. The first one gets one argument described as `var(left
border)' for which no completion will be offered because of the empty
action. The argument may come directly after the `tt(-l)' or it may be 
given as the next word on the line. The `tt(-format)' option gets one
argument (in the next word) described as `var(paper size)' for which
only the strings `tt(letter)' and `tt(A4)' will be completed. The
`tt(-copy)' option differs from the first two in that it may appear
more than once on the command line and in that it accepts two
arguments. The first one is mandatory and will be completed as a
filename. The second one is optional (because of the second colon
before the description `var(resolution)') and will be completed from
the strings `tt(300)' and `tt(600)'.

The last two descriptions say what should be completed as
arguments. The first one describes the first argument as a
`var(postscript file)' and makes files ending in `tt(ps)' or `tt(eps)' 
be completed. The last description says that all other arguments are
`var(page numbers)' but does not give possible completions.
)
item(tt(_values))(
This is used to complete values (strings) and their arguments or
lists of such values. If the first argument is the option `tt(-s)',
the second argument is used as the character that separates multiple
values.

The first argument (after the option and separator character if they
are given) is used as a string to print as a description before
listing the values.

All other arguments describe the possible values and their
arguments in the same format used for the description of options by
the tt(_arguments) function (see above). The only difference is that
there is no required minus or plus sign at the beginning and that
values can have only one argument.

Example:

example(_values -s , '...' \
        '*foo[bar]' \
        '(two)*one[number]:first count:' \
        'two[another number]::second count:(1 2 3)')

This describes three possible values: `tt(foo)', `tt(one)', and
`tt(two)'. The first one is described as `tt(bar)', gets no argument 
and may appear more than once. The second one is described as
`tt(number)', may appear more than once, and gets one mandatory
argument described as `tt(first count)' for which no action is
specified so that it will not be completed automatically. The
`tt((one))' at the beginning says that if the value `tt(one)' is on
the line, the value `tt(two)' will not be  considered to be a possible
completion any more. Finally, the last value (`tt(two)') is described
as `tt(another number)' and gets an optional argument decribed as
`tt(second count)' which will be completed from the strings `tt(1)',
`tt(2)', and `tt(3)'. The tt(_values) function will complete lists of
these values separated by commas.

To decide if the descriptions for the values (not those for the
arguments) should be printed, the configuration key
tt(describe_values) is used in the same way as the key
tt(describe_options) is used by the tt(_arguments) function.
)
enditem()

texinode(Completion Directories)(Bindable Commands)(Completion Functions)(Completion System)
sect(Completion Directories)
cindex(completion system, directory structure)

In the source distribution, the files are contained in various
subdirectories of the tt(Completion) directory.  They may have been
installed in the same structure, or into one single function directory.
The following is a description of the files found in the original directory
structure.  If you wish to alter an installed file, you will need to copy
it to some directory which appears earlier in your tt(fpath) than the
standard directory where it appears.

startitem()
item(tt(Core))(
The core scripts and functions.  You will certainly need these, though will
probably not need to alter them.  Many of these are documented above.
)
item(tt(Base))(
Other functions you will almost certainly want if you are going to use
any of the standard completion functions.  You may want to edit some of
these files.
)
item(tt(Builtins))(
Functions for completing arguments of shell builtin commands.
)
item(tt(User))(
Functions for completing arguments of external commands and suites of
commands.  They may need modifying for your system.
)
item(tt(Commands))(
Functions which implement special types of completion to be bound to
keystrokes rather than called by context.
)
enditem()

texinode(Bindable Commands)(Completion System Configuration)(Completion Directories)(Completion System)
sect(Bindable Commands)
cindex(completion system, bindable commands)

In addition to the context-dependent completions provided, which are
expected to work in an intuitively obvious way, there are a few widgets
implementing special behaviour which can be bound separately to keys.  The
following is a list of these and their default bindings.

startitem()
item(tt(_correct_filename (^XC)))(
Correct the filename path at the cursor position.  Allows up to six errors
in the name.  Can also be called with an argument to correct
a filename path, independently of zle; the correction is printed on
standard output.
)
item(tt(_correct_word) (^Xc))(
Performs correction of the current argument using the usual contextual
completions as possible choices. This uses the configuration keys with 
the prefix tt(correctword_) if they are set, see
ifzman(the section `Completion System Configuration' below)\
ifnzman(noderef(Completion System Configuration)).
)
item(tt(_expand_word (^Xe)))(
Performs expansion on the current word:  equivalent to the standard
tt(expand-word) command, but using all the `tt(expand_*)' configuration
keys described previously.  In addition, each such key can be overridden by
a key starting with the string `tt(expandword_)'; for example, the
tt(expandword_substitute) key if defined overrides the
tt(expand_substitute) key.
)
item(tt(_history_complete_word) (\e/))(
Complete words from the shell's command history.
)
item(tt(_most_recent_file (^Xm)))(
Complete the name of the most recently modified file matching the pattern
on the command line (which may be blank).  If given a numeric argument
var(N), complete the var(N)th most recently modified file.  Note the
completion, if any, is always unique.
)
item(tt(_read_comp (^X^R)))(
Prompt the user for a string, and use that to perform completion on the
current word.  There are two possibilities for the string.  First, it can
be a set of words beginning `tt(_)', for example `tt(_files -/)', in which
case the function with any arguments will be called to generate the
completions.  Unambiguous parts of the function name will be completed
automatically (normal completion is not available at this point) until a
space is typed.

Otherwise, any other string, for example `tt(-b)', will be passed as
arguments to tt(compgen) and should hence be a set of flags specifying the
type of completion.

A very restricted set of editing commands is available when reading the
string:  `tt(DEL)' and `tt(^H)' delete the last character; `tt(^U)' deletes
the line, and `tt(^C)' and `tt(^G)' abort the function, while `tt(RET)'
accepts the completion.  Note the string is used verbatim as a command
line, so arguments must be quoted in accordance with standard shell rules.

Once a string has been read, the next call to tt(_read_comp) will use the
existing string instead of reading a new one.  To force a new string to be
read, call tt(_read_comp) with a numeric argument.
)
item(tt(_verbose_list) (^Xv))(
This widget behaves like the builtin tt(delete-char-or-list) widget
but if called repeatedly with the same command line, it will make the
completion list more and more verbose. The default behavior is to
first show options even if the tt(option_prefix) configuration key is
set and to show option and value descriptions, too, on the next
invocation. Using the tt(verboselist_stages) configuration key it is
possible to change this default behavior, see
ifzman(the section `Completion System Configuration' below)\
ifnzman(noderef(Completion System Configuration)). Also, the
tt(_oldlist) completer has support for this command, which is
described in the entry for the tt(oldlist_menu) configuration key.

Since this widget normally behaves like tt(delete-char-or-list) you
may find it convenient to bind it to tt(^D).
)
enditem()

texinode(Completion System Configuration)()(Bindable Commands)(Completion System)
sect(Completion System Configuration)
cindex(completion system, configuring, summary)

Here is a list of parameters and configuration keys used by the
completion system.

subsect(Parameters)

These parameters may be set by the user to change the behavior of the
completion system:

startitem()
item(tt(users))(
This may be set to an array of names that should be completed whenever 
a username is needed. If it is not set or the string on the line
doesn't match any of the strings in this array, all usernames will be
completed.
)
item(tt(groups))(
An array holding the names of the groups that should be completed. If
this is not set by the user, it will automatically be set to a list
of group names taken from the YP database or the file `tt(/etc/group)'.
)
enditem()

subsect(Configuration keys)

startitem()
item(tt(completer))(
The colon-separated list of completer function to use.
)
item(tt(dumpfile))(
Set internally to the pathname of the dumpfile.
)
item(tt(group_matches))(
If set to a non-empty string, matches of different types will be put
in different groups, so that they are listed separately and not mixed
when using menu completion.
)
item(tt(describe_options))(
If set to a non-empty strings, options will be described when they are 
listed. If the value string contains substrings of the form
`tt(!)var(command)', this will not be done for any of these
var(command)s.
)
item(tt(describe_values))(
Like tt(describe_options), but used when completing value lists.
)
item(tt(description_format))(
A string to display above matches. The sequence `tt(%d)' in this
string will be replaced with a short description of what these matches 
are. This string may also contain the sequences to specify output
attributes, such as `tt(%b)' and `tt(%s)'.
)
item(tt(message_format))(
Like tt(description_format), but used when displaying messages in
those places where no completions can automatically be generated.
)
item(tt(option_prefix))(
If set to a non-empty value, options will only be generated as
possible matches when no other completions could be found or if the
string on the line begins with a option prefix character (a minus or a 
plus sign). This value may also contain strings of the form
`tt(!)var(command)' which makes options be always completed for all
var(command)s given in this way. Finally, if the value of this key
begins with `tt(hide)', the prefix characters `tt(-)', `tt(+)', or
`tt(-)tt(-)' will not be shown in the list.
)
item(tt(last_prompt))(
If this is set to tt(always), the cursor will always be moved back to
the last prompt if that is still visible, independent of the setting
of the tt(ALWAYS_LAST_PROMPT) option.
)
item(tt(approximate_accept))(
This should be set to the number of errors the correction code should
accept. The completer will try to generate completions by first allowing
one error, then two errors, and so on, until either a match
was found or the maximum number of errors given by this key has
been reached.

If the value for this key contains a lower- or upper-case `tt(n)', the 
completer function will take any numeric argument as the
maximum number of errors allowed. For example, with

example(compconf approximate_accept=2n)

two errors will be allowed if no numeric argument is given. However,
with a numeric argument of six (as in `tt(ESC-6 TAB)'), up to six
errors are accepted.  Hence with a value of `tt(0n)', no correcting
completion will be attempted unless a numeric argument is given.

If the value contains `tt(n)' or `tt(N)' and an exclamation mark
(`tt(!)'), tt(_approximate) will var(not) try to generate corrected
completions when given a numeric argument, so in this case the number given
should be greater than zero.  For example, `tt(2n!)' specifies that
correcting completion with two errors will usually be performed, but if a
numeric argument is given, correcting completion will not be performed.
)
item(tt(approximate_insert))(
If this is set to a string starting with `tt(unambig)', the code will try
to insert a usable unambiguous string in the command line instead of
always cycling through the corrected strings. If such a unambiguous
string could be found, the original string is not used, independent of
the setting of tt(approximate_original). If no sensible string could be
found, one can cycle through the corrected strings as usual.
)
item(tt(approximate_original))(
This key is used to specify whether the original string on which correcting 
completion was attempted is to be included in the list of possible
corrections. If it is set to any non-empty string, the original string 
will be offered when cycling through the completions. Normally it will 
appear as the first string, so that the command line does not change
immediately; consecutive completion attempts will cycle through the
corrected strings.  If the value for this key contains the substring
`tt(last)', the original string will be the last one in the list, so
that it appears just before wrapping around to the first corrected
string again.  Also, if the value contains the substring `tt(always)',
the original string will always be included; normally it is
included only if more than one possible correction was generated. And
finally, if the value contains the substring `tt(show)', the original
string will be shown in the list of corrections.
)
item(tt(approximate_prompt))(
This can be set to a string to be displayed on top of the
corrected strings generated when cycling through them. This string
may contain the control sequences `tt(%n)', `tt(%B)', etc. known from
the `tt(-X)' option of tt(compctl). Also, the sequence `tt(%e)' will
be replaced by the number of errors accepted to generate the corrected 
strings.
)
item(tt(correct_accept), tt(correct_insert), tt(correct_original), tt(correct_prompt))(
These keys are used by the tt(_correct) completer instead of the forms
beginning with tt(approximate_) described above.
)
item(tt(correctword_accept), tt(correctword_insert),
tt(correctword_original), tt(correctword_prompt))(
These keys are used by the tt(_correct_word) bindable command to
override the values of tt(correct_accept), tt(correct_insert),
tt(correct_original), and tt(correct_prompt) if they are set.
)
item(tt(expand_substitute))(
If this is unset or set to the empty string, the code will first try
to expand all substitutions in the string (such as
`tt($LPAR()...RPAR())' and `tt(${...})'). If this is set to an
non-empty string it should be an expression usable inside a `tt($((...)))'
arithmetical expression. In this case, expansion of substitutions will
be done if the expression evaluates to `tt(1)'. For example, with

example(compconf expand_substitute='${NUMERIC:-1} != 1')

substitution will be performed only if given an explicit numeric
argument other than `tt(1)', as by typing `tt(ESC 2 TAB)'.
)
item(tt(expand_glob))(
If this is unset or set to an empty string, globbing will be attempted
on the word resulting from substitution or the original string. The
values accepted for this key are the same as for tt(expand_substitute).
)
item(tt(expand_menu))(
If this is unset or set to the empty string, the words resulting from
expansion (if any) will simply be inserted in the command line,
replacing the original string. However, if this key is set to a
non-empty string, the user can cycle through the expansion as in
menucompletion. Unless the value contains the substring `tt(only)',
the user will still be offered all expansions at once as one of the
strings to insert in the command line; normally, this possibility is
offered first, but if the value contains the
substring `tt(last)', it is offered last. Also, if the value contains
the substring `tt(sort)', the expansions will be sorted alphabetically,
normally they are kept in the order the expansion produced them in.
And finally, if the value contains the substring `tt(showall)', the
string of all words will be shown in the list of expansions.
)
item(tt(expand_original))(
If this is set to an non-empty string, the original string from the
line will be included in the list of strings the user can cycle
through as in a menucompletion. If the value contains the substring
`tt(last)', the original string will appear as the last string, with
other values it is inserted as the first one (so that the command line
does not change immediately). Also, if the value contains the
substring `tt(show)', the original string will be shown in the list of 
expansions.
)
item(tt(expand_prompt))(
This may be set to a string that should be displayed before the
possible expansions. This is passed to the `tt(-X)' option of
tt(compadd) and thus may contain the control sequences `tt(%n)',
`tt(%B)', etc. Also, the sequence `tt(%o)' in this string will be
replaced by the original string.
)
item(tt(expandword_substitute), tt(expandword_glob),
tt(expandword_menu),tt(expandword_original), tt(expandword_prompt))(
If these keys are set, they are used by the tt(_expand_word) bindable
command to override the values for the configuration keys with the
tt(expand_) prefix.
)
item(tt(list_condition))(
If this key is unset or set to the empty string, the insertion of
matches will be delayed unconditionally. If this value is set, it
should be set to an expression usable inside a `tt($((...)))'
arithmetical expression. In this case, delaying will be done if the
expression evaluates to `tt(1)'. For example, with

example(compconf list_condition='NUMERIC != 1')

delaying will be done only if given an explicit numeric argument
other than `tt(1)'.
)
item(tt(list_word))(
To find out if listing should be performed on its own, the code normally
compares the contents of the line with the contents the line had at the
time of the last invocation. If this key is set to an non-empty string,
comparison is done using only the current word. So if it is set,
attempting completion on a word equal to the one when completion was called
the last time will not delay the generation of matches.
)
item(tt(match_original))(
If set too tt(only), the tt(_match) completer will try to generate
matches without inserting a `tt(*)' at the cursor position. If set to
any other non-empty value, it will first try to generate matches
without inserting the `tt(*)' and if that yields no matches, it will
try again with the `tt(*)' inserted.
)
item(tt(match_insert))(
If this is set to a string starting with tt(unambig), the tt(_match)
completer will start menu completion only if no unambiguous string
could be generated that is at least as long as the original string
from the line.
)
item(tt(oldlist_list))(
If this is set to tt(always), then standard widgets which perform listing
will retain the current list of matches, however they were generated.  If
it is set to tt(never), this will not be done (the behaviour without the
tt(_oldlist) completer).  If it is unset, or any other value, then the
existing list of completions will be displayed if it is not already;
otherwise, the standard completion list will be generated:  this is the
default behaviour of tt(_oldlist). However, if there is an old list
and this key contains the name of the completer function that
generated the list, then the old list will be used even if it was
generated by a widget which does not do listing.

For example, suppose you type tt(^Xc) to use the tt(_correct_word)
widget, which generates a list of corrections for the word under the
cursor.  Usually, typing tt(^D) would generate a standard list of
completions for the word on the command line, and show that.  With
tt(_oldlist), it will instead show the list of corrections already
generated.

As another example consider the tt(_match) completer: with the
tt(match_insert) key set to tt(unambig) it inserts only an
unambiguous prefix string if there is any. But since this may remove
parts of the original pattern, attempting completion again may result
in more matches than on the first attempt. But by using the
tt(_oldlist) completer and setting this key to tt(_match), the list of 
matches generated on the first attempt will be used again.
)
item(tt(oldlist_menu))(
Controls how menu completion behaves when a completion has already been
inserted and the user types a standard completion key type such as tt(TAB).
The default behaviour of tt(_oldlist) is that menu completion always
continues with the existing list of completions.  If this key is set to
tt(never), however, a new completion is started if the old list was
generated by a different completion command (the behaviour without the
tt(_oldlist) completer).

For example, suppose you type tt(^Xc) to generate a list of corrections,
and menu completion is started in one of the usual ways.  Usually, typing
tt(TAB) at this point would start trying to complete the line as it now
appears.  With tt(_oldlist), it will instead continue to cycle through the
list of completions.

With this key, the tt(_oldlist) completer also has additional support
for the tt(_verbose_list) bindable command: when it is set to
tt(verbose), invoking the tt(_oldlist) completer after a different
list has been shown by calling the tt(_verbose_list) command will make 
completion re-use this list, so that, for example, menu completion
will be started when the tt(AUTO_LIST) option is set.
)
item(tt(verboselist_stages))(
This key is used by the tt(_verbose_list) bindable command to find out 
when options or descriptions should be shown. It is a colon-separated
list of the keywords tt(normal), tt(options) and tt(describe). The
keywords are used in the order in which they appear to describe what
should be listed on the next call to the widget (with an unchanged
command line). The value tt(normal) says that the list should be
generated as defined by the normal settings of the configuration
keys, the value tt(options) says that options should be listed even if 
the tt(option_prefix) configuration key is set, and tt(describe) says
that options and values should be described. The last two can be
combined as in tt(describe-options) to make both options being listed
and options and values being described.

For example, if tt(option_prefix) is set to any non-empty value,
tt(describe_options) is not set and tt(verboselist_stages) is set to
tt(describe:normal) invoking the tt(_verbose_list) widget with a list
being shown will replace this list with a list containing also option
names that are possible matches and will also make these options be
described if possible. Consecutively invoking the tt(_verbose_list)
widget will then toggle between the normal list form and the extra
verbose one.
)
item(tt(path_expand))(
This is used by the tt(_path_files) function which is used throughout
the completion system to generate filenames. If this is set to any
non-empty string, the partially typed path from the line will be
expanded as far as possible even if trailing pathname components can
not be completed.
)
item(tt(path_cursor))(
Like tt(path_expand), this is used by the tt(path_files) function. If
this is set to a non-empty string, the cursor will be left after the
first ambiguous pathname component even when menucompletion is used.
)
item(tt(ps_args))(
This key is used by completion functions that call the unix command
tt(ps) to generate process IDs as matches. Its value is given to
tt(ps) as its argument when calling it to get the IDs of process to
complete.
)
item(tt(ps_listargs))(
Like tt(ps_args), this key is used by functions that call tt(ps) to
generate process IDs as matches. These functions will display the
output of tt(ps) called with the value of this key as its argument
when showing completion lists.
)
item(tt(urls_path))(
This key is used by completion functions that generate URLs as
possible matches. It should be set to the path of a directory
containing sub-directories named like `tt(http)', `tt(ftp)',
`tt(bookmark)', and so on. These sub-directories should contain files
and other sub-directories whose pathnames are possible completions
after the initial `tt(http://)', `tt(ftp://)', etc. See the
description in the file tt(_urls) in the tt(User) sub-directory of the 
completion system for more information.
)
item(tt(colors_path))(
This is used by functions that complete color names. It should be set
to the pathname of a file containing color names in the format of an
X11 tt(rgb.txt) file.
)
item(tt(history_sort))(
If this is set to a non-empty string, completion functions that
generate words from the history as possible matches sort these words
alphabetically instead of keeping them in the order in which they
appear in the history (from youngest to oldest).
)
item(tt(cvs_disable_stat))(
This is used by the completion function for the tt(cvs) command. If it 
is set to a non-empty value, this function will not try to use the
tt(stat) module to generate only names of modified files in the
appropriate places.
)
enditem()
