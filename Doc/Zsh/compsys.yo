texinode(Completion System)(Zftp Function System)(Zsh Modules)(Top)
chapter(Completion System)
cindex(completion system)
cindex(completion, programmable)
cindex(completion, controlling)
sect(Description)

This describes the shell code for the new completion system.  It consists
of various shell functions; those beginning `tt(comp)' are to be called
directly by the user, while those beginning `tt(_)' are called by the
completion code.  The shell functions of the second set which implement
completion behaviour and which may be bound to keystrokes, are referred to
as `widgets'.

Note that with the function-based completions described here, it
is also possible to use the 
tt(compmatchers) special array to specify
global matching control, such as case-insensitivity (`tt(abc)' will complete
to a string beginning `tt(ABC)'), or wildcard behaviour on
certain anchors (`tt(a-d)' will complete to abc-def as if there were a
`tt(*)' after the `a').  See
ifzman(the section `Matching Control' in zmanref(zshcompwid))\
ifnzman(noderef(Matching Control))
for further details.

startmenu()
menu(Initialization)
menu(Completion System Configuration)
menu(Control Functions)
menu(Bindable Commands)
menu(Completion Functions)
menu(Completion Directories)
endmenu()

texinode(Initialization)(Completion System Configuration)()(Completion System)
sect(Initialization)
findex(compinstall)
cindex(completion system, installing)

The function tt(compinstall) can be run by a user to set up the completion
system for use, which also provides options for more advanced usage.
However, if the system was installed completely, it should be enough to
call the shell function tt(compinit) from your initialization file; see the
next section.

Usually, tt(compinstall) will insert code into tt(.zshrc), although if
that is not writable it will save it in another file and tell you that
file's location.  Note that it is up to you to make sure that the lines
added to tt(.zshrc) are actually run; you may, for example, need to move
them to an earlier place in the file if tt(.zshrc) usually returns early.
So long as you keep them all together (including the comment lines at the
start and finish), you can rerun tt(compinstall) and it will correctly
locate and modify these lines.  Note, however, that any code you add to
this section by hand is likely to be lost if you rerun tt(compinstall).
The new code will take effect next time you start the shell, or run
tt(.zshrc) by hand.

To run it, you will need to make sure it is in a directory mentioned in your
tt($fpath) parameter, and that it is autoloaded (`tt(autoload -U
compinstall)' is recommended).  It will ask you various questions about how
you would like completion set up.  It is in two parts; the basic part
locates the completion files and decides where to put your personal
dumpfile, used to speed up initialization after the first time.  After
that, you will be asked if you wish to go on to the advanced set-up; if you
answer tt(n), you can rerun tt(compinstall) later without having to
re-enter any of the basic settings.

You can abort the installation any time you are being prompted for
information, and your tt(.zshrc) will not be altered at all.

After initialization all the builtin completion widgets such as
tt(expand-or-complete) will be redefined to use the new completion system.
Should you need to, you can still bind keys to the old functions by putting
a `tt(.)' in front, e.g. `tt(.expand-or-complete)'.

subsect(Use of compinit)
findex(compinit)
cindex(completion system, initializing)

This section describes the use of tt(compinit) to initialize completion for
the current session when run directly by the user; if you have run
tt(compinstall) it will be called automatically from your tt(.zshrc).

To initialize the system, the function tt(compinit) should be in a
directory mentioned in the tt($fpath) variable, and should be autoloaded
(`tt(autoload -U compinit)' is recommended).  When run, it will define a
few utility functions, arrange for all the necessary shell functions to be
autoloaded, and will then re-bind all keys that do completion to use the
new system.

To speed up the running of tt(compinit), it can be made to produce a dumped
configuration which will be read in on future invocations; this is the
default, although it can be turned off by calling tt(compinit) with the
option tt(-D).  The dumped file is tt(.zcompdump) in the same
directory as the startup files (i.e. tt($ZDOTDIR) or tt($HOME));
alternatively, an explicit file name can be given by `tt(compinit -d)
var(dumpfile)'.  On the next call to tt(compinit), the dumped file will be
read instead of a full initialization.

If the number of completion files changes, tt(compinit) will recognise this
and produce a new dump file.  However, if the name of a function or the
arguments in the first line of a tt(#compdef) function (as described below)
change, it is easiest to delete the dump file by hand so that the next time
tt(compinit) will re-create it.

The dumping is actually done by another function, tt(compdump), but you
will only need to run this yourself if you change the configuration
(e.g. using tt(compdef)) and then want to dump the new one.  The name of
the old dumped file will be remembered for this purpose.

If the parameter tt(_compdir) is set, tt(compinit) uses it as a directory
where completion functions can be found; this is only necessary if they are
not already in the function search path.

subsect(Autoloaded files)
cindex(completion system, autoloaded functions)

The convention for autoloaded functions used in completion is that they
start with an underscore; as already mentioned, the tt(fpath/FPATH)
parameter must contain the directory in which they are stored.  If tt(zsh)
was properly installed on your system, then tt(fpath/FPATH) automatically
contains the required directories.

For incomplete installations, if tt(compinit) does not find enough files
beginning with an underscore (fewer than twenty) in the search path, it
will try to find more by adding the directory tt(_compdir) to the search
path; if you have run tt(compinstall), this will be set automatically.
Furthermore, if the directory in question ends in the path segment
tt(Core), or has a subdirectory named tt(Core), tt(compinit) will add all
subdirectories of the directory where tt(Core) is to the path: this allows
the functions to be in the same format as in the tt(zsh) source
distribution.

When tt(compinit) is run, it searches all such files accessible via
tt(fpath/FPATH) and reads the first line of each of them.  This line should
contain one of the tags described below. Files whose first line does not
start with one of these tags are not considered to be part of the
completion system and will not be treated specially.

The tags are:

startitem()
item(tt(#compdef) var(names...))(
The file will be made autoloadable and the function defined 
in it will be called when completing var(names), each of which is
either the name of a command whose arguments are to be completed or one of
a number of special contexts in the form tt(-)var(context)tt(-) described
below for the tt(_complete) function.
)
item(tt(#compdef -p) var(pattern))(
The file will be made autoloadable and the function defined in it will be
called when completing for a command whose name matches the given
var(pattern) (a standard globbing pattern).  Note that only one
var(pattern) may be given.
)
item(tt(#compdef -P) var(pattern))(
Like the previous one, but the function will be called only if no
completion function for the command on the line could be found.
)
item(tt(#compdef -k) var(style key-sequences...))(
This can be used to bind special completion functions to the
var(key-sequences).  It creates a widget behaving like the builtin widget
var(style), which must be one of those that perform completion, namely
tt(complete-word), tt(delete-char-or-list), tt(expand-or-complete),
tt(expand-or-complete-prefix), tt(list-choices), tt(menu-complete),
tt(menu-expand-or-complete), or tt(reverse-menu-complete). If the
tt(complist) module is loaded (see
ifzman(zmanref(zshmodules))\
ifnzman(noderef(The complist Module))\
), the tt(menu-select) widget can be used, too.  Note that the
bindings will not be used if the key is already bound (that
is, is bound to something other than tt(undefined-key)).

The widget is then bound to all the var(key-sequences) given, if any: when
one of the var(key-sequences) is typed, the function in the file will
be invoked to generate the matches. The widget created has the same
name as the file and can also be bound to other keys using tt(bindkey) 
as usual.
)
item(tt(#compdef -K) var(widget-name) var(style) var(key-sequences) ...)(
This is similar to tt(-k), with the same var(style) and var(key-sequences)
arguments arguments, preceeded by a string giving the name of a widget.
In this case only one var(key-sequences) argument may be given, but the
entire set of three arguments may be repeated with a different set of
arguments.  In particular, the var(widget-name) must be distinct in each
set.  It should begin with `tt(_)', else one will be added, and should not
clash with the name of any existing widget: names based on the name of the
function are most useful.  For example,

example(#compdef -K _foo_complete complete-word "^X^C" \ 
  _foo_list list-choices "^X^D")

(all on one line) defines a widget tt(_foo_complete) for completion, bound
to `tt(^X^C)', and a widget tt(_foo_list) for listing, bound to `tt(^X^D)'.
)
item(tt(#autoload))(
This is used for files defining utility function that are not to be
called directly as completion functions but should be loaded automatically
when invoked.  Typically they are to be called from within one of the
completion functions.
)
enditem()

Note that the tt(#) is part of the tag name and no white space is allowed
after it.  The tt(#compdef) tags use the tt(compdef) function described
below; the main difference is that the name of the function is supplied
implicitly.

subsect(Functions)

The tt(compinit) file defines the following functions, which may
also be called directly by the user.

findex(compdef)
cindex(completion system, adding definitions)
startitem()
xitem(tt(compdef) [ tt(-an) ] var(function names...))
xitem(tt(compdef -d) var(names...))
xitem(tt(compdef -p) [ tt(-a) ] var(function pattern))
xitem(tt(compdef -P) [ tt(-a) ] var(function pattern))
xitem(tt(compdef -k) [ tt(-an) ] var(function style key-sequences...))
item(tt(compdef -K) [ tt(-an) ] var(function name style key-sequences ...))(
The first form tells the completion system to call the given
var(function) when completing for the contexts or commands
whose var(names) are given:  this is like the tt(#compdef) tag.  If the
tt(-n) option is given, any existing completion behaviour for particular
contexts or commands will not be altered.  These definitions can be deleted
by giving the tt(-d) option as in the second form.

The form with tt(-p) is similar to the first, but var(function) will be
called for all commands whose name matches the var(pattern); this is like
the tt(#compdef -p) function tag.

The form with tt(-P) is like the third, but the var(function) will be
called only if no function for the command itself was found or if one
was found and it set the tt(_compskip) parameter to a value em(not)
containing the substring `tt(patterns)'.

The form with tt(-k) defines a widget with the same name as the var(function)
which will be called for each of the var(key-sequences); this is like the
tt(#compdef -k) tag.  The function should generate the completions needed
and will otherwise behave like the builtin widget whose name is given as
the var(style) argument. The widgets usable for this are:
tt(complete-word), tt(delete-char-or-list), tt(expand-or-complete),
tt(expand-or-complete-prefix), tt(list-choices), tt(menu-complete),
tt(menu-expand-or-complete), and tt(reverse-menu-complete), as well as
tt(menu-select) if the tt(complist) module is loaded.  The option tt(-n)
prevents the key being bound if it is already to bound to something other
than tt(undefined-key).

The form with tt(-K) is similar and defines multiple widgets based on the
same var(function), each of which requires the set of three arguments
var(name), var(style) and var(key-sequences), where the latter two are as
for tt(-k) and the first must be a unique widget name beginning with an
underscore.

In each of the forms supporting it the tt(-a) option makes the
var(function) autoloadable (exactly equivalent to
tt(autoload -U )var(function)).
)
findex(compstyle)
cindex(completion system, configuring)
xitem(tt(compstyle) var(pattern) var(style) var(strings ...))
xitem(tt(compstyle -d) [ var(pattern) [ var(styles ...) ] ])
item(tt(compstyle) [ tt(-L) ] )(
Several aspects of the completion system can be configured by the
user. This function allows to define so-called styles that are used by 
various completion functions. These styles are associated with
patterns that are compared to context names used by the completion
system. The configuration possibilities are explained in detail in
ifzman(the section `Completion System Configuration' below)\
ifnzman(noderef(Completion System Configuration))\
.

In the first form a new var(style) is defined for a certain
var(pattern), setting it to the value given by the var(strings). If there 
was already a definition for the same var(pattern)/var(style) pair,
only the value is changed.

The second form with the tt(-d) option can be used to delete
definitions made by previous calls with the first form. Without any
arguments all definitions are removed. If a var(pattern) is given, all 
styles defined for it are removed and if a var(pattern) and any number 
of var(styles) are given, only those styles are removed for the
pattern.

In the last form (without arguments) all definitions are listed. If
the tt(-L) option is given this is done in the form of calls to
tt(compstyle).
)
enditem()

texinode(Completion System Configuration)(Control Functions)(Initialization)(Completion System)
sect(Completion System Configuration)
cindex(completion system, configuration)

The completion system allows users to configure many aspects of how
and when matches are generated. After a short overview of how the
completion system works, this section describes how this can be done.

subsect(Overview)

When completion is attempted somewhere on a command line the
completion system first tries to find out the context where completion 
was tried. Such a context depends, for example, on the name of the
command when completing an argument. Or it may depend on both the name 
of a command and the name of an option when completing after one that
takes arguments.

The completion system represents such a context as a hierarchical name 
with components separated by colons. For example the name
tt(:complete::dvips::-o-1) is used when completing the first argument of 
the tt(-o) option of the tt(dvips) command. The tt(:complete) at the
beginning just says that we are currently trying completion as opposed 
to, say, correction, which can also be done using the function based
completion system (see
ifzman(the section `Control Functions' below)\
ifnzman(noderef(Control Functions)) 
for more information). And the tt(::dvips:) shows that we are
completing arguments for the tt(dvips) command. Such a doubled colon
will appear only before and after the name of the command, but note
that the second colon after the command name is really only added when 
there is at least one more component (otherwise the whole name ends in 
a colon).

In many of the possible contexts the completion system can generate
matches, and often it can generate multiple types of matches. Whenever 
a completion function is about to generate such matches it first calls 
a utility function, telling it what types of matches can be
generated. These types are represented as simple names called
`tags'. This utility function in turn calls another function
(tt(_sort_tags)) and gives the list of tags to it as
arguments. The function tt(_sort_tags) can then say in which order the 
tags are to be used by the completion function. The function will 
only generate those types of matches whose tags were selected by the
user's implementation of the tt(_sort_tags) function. And it will
try to generate the different types of matches in the order in which
they were specified by tt(_sort_tags).

Inside the tt(_sort_tags) function the name of the current context can
be accessed using the tt(curcontext) parameter. For example, the
function generating file names (called tt(_files)) in the completion
system is often called to generate only filenames matching a given
glob pattern and then uses the tags tt(globbed-files),
tt(directories), and tt(all-files). This means that the function
offers to generate filenames matching the pattern, names of
directories or all filenames as possible matches. Now, if the user has
this definition for tt(_sort_tags):

example(_sort_tags() {
  case $curcontext in
  (*::dvips:*)
    comptry globbed-files directories
    comptry all-files
    ;;
  (*)
    comptry globbed-files
    comptry directories
    comptry all-files
    ;;
  esac
})

Every call to the tt(comptry) function (well, it's actually a builtin
command defined by the tt(computil) module, but never mind) gives a
set of tags to use. So, the first call says which tags are to be used 
first. If there are no matches for those tags, the tags from the
second call to tt(comptry) will be tried, and so on. In the example
this means that for the tt(dvips) command on the first attempt the
names of DVI files and directories will be generated (first call to
tt(comptry)). If none of those names match the string from the command
line the completion function will generate all filenames as
possible matches (second call to tt(comptry)).

For all other context names the second case-pattern matches, so that
normally the completion functions will only try the filenames matching 
the glob pattern (if any glob pattern is used). If that doesn't yield
any matches, names of directories are generated, and if that doesn't
yield any matching names either, all filenames will be generated.

In every context the tt(_sort_tags) function may call tt(comptry) as
often as it wants. Also, every string may be given as argument, even
if no tag with such a name was offered by the completion
function. This allows one to give a preferred ordering for some common 
tag sets without having to worry about sensible patterns for context
names. For example, many completion functions can generate both
arguments and option names for commands. These functions normally use
the tags tt(arguments) and tt(options). Depending on your preference
you may write in your tt(_sort_tags) function:

example(_sort_tags() {
  comptry arguments options
  case $curcontext in
  ...
  esac
})

or

example(_sort_tags() {
  comptry arguments
  comptry options
  case $curcontext in
  ...
  esac
})

The former always adds both the matches for the argument and the
option names as possible matches. The latter makes the matches for the 
arguments be preferred. In this case option names are only generated
as matches if the string on the line matches no possible completion
for the argument, which normally means that you have to type the
hyphen the option names start with yourself to see the list of option
names that can be completed.

Since the completion functions are free to choose the tag names they
use, there can't be a complete list. So to make sure that all types of 
matches are eventually tried as completions, one should  use a call to 
tt(comptry) with all arguments at the end of tt(_sort_tags). For those
contexts where one really wants to make sure that certain tags are
never used one can then use a call to tt(return) to circumvent that
last tt(comptry). For example:

example(_sort_tags() {
  ...
  case $curcontext in
  (*::kill:*)
    comptry processes
    return
    ;;
  esac
  comptry "$@"
})

The completion function for the tt(kill) builtin command offers the
tags tt(jobs) and tt(processes) which represent job references
(e.g. `tt(%1)') and process identifiers respectively. The function
above makes sure that for this builtin command only process
identifiers are generated as possible matches by using only the
tt(processes) tag in a call to tt(comptry). The immediate call to
tt(return) then makes sure that the default tt(comptry) at the end is
not executed.

The tt(_complete_help) bindable command described in 
ifzman(the section `Bindable Commands' below)\
ifnzman(noderef(Bindable Commands))
can be used to find out the contexts and tag names used by completion
functions. If it is invoked, it shows a list of context names and the
tag names used in those contexts if completion were tried at the
current cursor position. This allows one to easily find out all the
information needed to change the tt(_sort_tags) function when one
wants to change the way matches are generated for that context.

But the tt(_sort_tags) function is only one half of the configuration
possibilities of the completion system. The other half uses the
`styles' defined with the tt(compstyle) function mentioned in
ifzman(the section `Initialization' above)\
ifnzman(noderef(Initialization))\
.

For some tags the completion functions look up the definition of
certain styles set for the current context. These styles can have any
number of strings as their values and specify, for example, how the
matches are generated. The tt(compstyle) function defines mappings
between patterns and style names with their values. Whenever a
completion function looks up the value of a style it uses the name of
the current context followed by a colon and the name of a tag. This
combined name and the name of a style is then compared to all patterns
and the value of the style for the first matching pattern is used.

For example, many completion functions can generate matches in a
simple and a verbose form and use the tt(verbose) style to decide
which form should be used. To make all such functions always use the
verbose form one can simply call

example(compstyle '*' verbose yes)

in one of the startup files like tt(.zshrc) (after the call to the
tt(compinit) function). This definition simply means that the
tt(verbose) style has tt(yes) as its value in every context.

The completion function for the tt(kill) builtin command uses this
style to decide if jobs and processes are listed only as job numbers
and process identifiers or if they are listed with the full job texts
and the command lines of the processes (the latter is achieved by
calling the tt(ps) command). To make this builtin list the matches
only as numbers one could call:

example(compstyle '*::kill:*' verbose no)

And if one wants to see the command lines for processes but not the
job texts one could use the fact that the tag name is appended to the
context name when styles are looked up and instead of the previous
call use (remember that the function for the tt(kill) builtin command
uses the tags tt(jobs) and tt(processes)): 

example(compstyle '*::kill:*:jobs' verbose no)

As said above, the patterns given to the tt(compstyle) function are
tested in the order in which they were given. But that isn't
completely true. In fact, this function roughly sorts the patterns so
that more specialized patterns are compared before more general
patterns. Due to this, the last two examples could be defined after
the first one because both `tt(*::kill:*)' and `tt(*::kill:*:jobs)' are
considered to be more specific then the pattern `tt(*)' from the first
example. To decide how specific a pattern is, the function looks at 
the number of colons (corresponding to the number of components) used
in the pattern, and if these components are actual patterns (like the
`tt(*)') or simple strings (like the `tt(jobs)' in the last
example). Patterns with fewer colons and fewer simple strings are
considered to be less specific.

As for tags, completion functions can use any number of styles, so
there can't be a complete list. However, the following two sections
list those tags and styles that are used in many places of the
completion system.

subsect(Standard Tags)
cindex(completion system, tags)

Here are the tags currently used by the completion system. Note that
some of these tags are not really used when generating mathes but
instead are only used by some completion functions when looking up
styles.

startitem()
item(tt(accounts))(
used to look up the tt(users-hosts) style
)
item(tt(all-files))(
for the names of all files
)
item(tt(all-expansions))(
used by the tt(_expand) completer when adding the string containing
all expansions
)
item(tt(arguments))(
when an argument of a command may be completed
)
item(tt(arrays))(
for names of array parameters
)
item(tt(association-keys))(
for keys of associative arrays (e.g. when completing inside a
subscript of such a parameter)
)
item(tt(bookmarks))(
when completing bookmarks (e.g. for URLs and the tt(zftp) function suite)
)
item(tt(builtins))(
for names of builtin commands
)
item(tt(characters))(
used for commands like tt(stty) when completing characters; also used
when completing character classes after a opening bracket
)
item(tt(colors))(
for color names
)
item(tt(commands))(
for names of external commands and names of sub-commands (used by some 
commands like tt(cvs))
)
item(tt(corrections))(
used by the tt(_approximate) completer for the possible corrections
)
item(tt(cursors))(
for cursor names used by X programs
)
item(tt(cvs))(
used only to look up the value of the tt(disable-stat) style
)
item(tt(descriptions))(
used when looking up the value of the tt(format) style for
descriptions
)
item(tt(devices))(
for names of device special files
)
item(tt(directories))(
for names of directories
)
item(tt(directory-stack))(
for entries in the directory stack
)
item(tt(displays))(
for X display names
)
item(tt(expansions))(
used by the tt(_expand) completer for possible expansions
)
item(tt(extensions))(
for X server extensions
)
item(tt(files))(
used by completion functions that can complete some kind of filenames
and different types of matches
)
item(tt(fonts))(
used for X font names
)
item(tt(functions))(
names of functions (shell functions or other kinds of functions for
some commands)
)
item(tt(globbed-files))(
for names of files matching the glob pattern used by completion
functions that expect a certain type of file
)
item(tt(groups))(
used when completing names of user groups
)
item(tt(history-words))(
for words from the history
)
item(tt(hosts))(
for hostnames
)
item(tt(indexes))(
used for array indexes
)
item(tt(jobs))(
used for jobs
)
item(tt(keymaps))(
for names of zsh keymaps
)
item(tt(keysyms))(
for names of X keysyms
)
item(tt(local-directories))(
for names of directories in the current working directory when
completing for the tt(cd) builtin command
)
item(tt(libraries))(
for names of system libraries
)
item(tt(limits))(
for system limits
)
item(tt(manuals))(
for names of manual pages
)
item(tt(maps))(
for map names (e.g. YP maps)
)
item(tt(messages))(
used to look up the tt(format) style for messages
)
item(tt(modifiers))(
for names of X modifiers
)
item(tt(modules))(
for modules (e.g. tt(zsh) modules)
)
item(tt(my-accounts))(
used to look up the tt(users-hosts) style
)
item(tt(named-directories))(
for named directories (you wouldn't have guessed that, would you?)
)
item(tt(names))(
for all kinds of names
)
item(tt(nicknames))(
for nicknames of YP maps
)
item(tt(options))(
for command options
)
item(tt(original))(
used by the tt(_approximate) and tt(_expand) completers when adding
the original string
)
item(tt(other-accounts))(
used to look up the tt(users-hosts) style
)
item(tt(packages))(
for packages (e.g. tt(rpm) packages)
)
item(tt(parameters))(
for names of parameters
)
item(tt(path-directories))(
for names of directories in directories from the tt(cdpath) array when
completing for the tt(cd) builtin command
)
item(tt(paths))(
used to look up the values of the tt(expand) and tt(cursor) styles
)
item(tt(pods))(
for perl pods
)
item(tt(ports))(
for communication ports
)
item(tt(prefixes))(
for prefixes (like those of an URL)
)
item(tt(processes))(
for process identifiers
)
item(tt(ps))(
used to look up the tt(arguments) and tt(list-arguments) styles
)
item(tt(regex))(
used to look up tt(cache-path) style
)
item(tt(sequences))(
for sequences (e.g. tt(mh) sequences)
)
item(tt(sessions))(
for sessions in the tt(zftp) function suite
)
item(tt(signals))(
for signal names
)
item(tt(strings))(
for strings (e.g. the replacement strings for the tt(cd) builtin
command)
)
item(tt(tags))(
for tags (e.g. tt(rpm) tags)
)
item(tt(targets))(
for makefile targets
)
item(tt(types))(
for types of whatever (e.g. adress types for the tt(xhost) command)
)
item(tt(urls))(
used to look up the tt(path) and tt(local) styles when completing URLs
)
item(tt(users))(
for usernames
)
item(tt(values))(
when completing a value out of a set of values (or a list of such
values)
)
item(tt(warnings))(
used to look up the tt(format) style for warnings
)
item(tt(widgets))(
for zsh widget names
)
item(tt(windows))(
for IDs of X windows
)
item(tt(zsh-options))(
for shell options
)
enditem()

subsect(Standard Styles)
cindex(completion system, styles)

Here are the names of the styles used by the completion system. Note
that the values of several of these styles represent boolean
values. In all these cases any of the strings `tt(true)', `tt(on)',
`tt(yes)', and `tt(1)' can be used for the truth value `true' and
every other value (or if the style is not set at all for the context
in which it is looked up) stands for `false'.

em(NOTE: Maybe we should sort them differently. Or maybe we should
explain some of them only when explaining the completers that use
them.)

startitem()
item(tt(arguments))(
The value of this style is given to the tt(ps) command by functions
that call it when generating process identifiers as matches.
)
item(tt(auto-description))(
If set, this style's value will be used as the description for options which
are not described by the completion functions, but that have exactly
one argument. The sequence `tt(%d)' in the value will be replaced by
the description for this argument. Depending on personal preferences,
it may be useful to set this style to something like `tt(specify: %d)'. 
Note that this may not work for some commands.
)
item(tt(cache-path))(
The tt(_regex_arguments) utility function used by some completion
functions creates shell functions on the fly. If this style is set to
a non-empty string, the value is taken as the name of a directory
where to store these functions so that they don't have to be created
anew when the completion function is used in another shell.
)
item(tt(completer))(
The strings given as the value of this style give the names of the
completer functions to use. The available completer functions are
described in
ifzman(the section `Control Functions' below)\
ifnzman(noderef(Control Functions))\
.
)
item(tt(completions))(
This style is used by the tt(_expand) completer function.

If this is set to an non-empty string it should be an expression
usable inside a `tt($((...)))' arithmetical expression. The completer
function evaluates this expression and if the result is `tt(1)', no
expansions will be generated, but instead the completions will be
generated as normal and all of them will be inserted into the command
line.
)
item(tt(condition))(
This style is used by the tt(_list) completer function.

If it is not set or set to the empty string, the insertion of
matches will be delayed unconditionally. If this value is set, it
should be set to an expression usable inside a `tt($((...)))'
arithmetical expression. In this case, delaying will be done if the
expression evaluates to `tt(1)'. For example, with

example(compstyle ':list' condition 'NUMERIC != 1')

delaying will be done only if given an explicit numeric argument
other than `tt(1)'.
)
item(tt(cursor))(
This is used together with the tt(paths) tag by the function
generating filenames as matches to find out if the cursor will be left
after the first ambiguous pathname component even when menucompletion
is used.
)
item(tt(disable-stat))(
This is used with the tt(cvs) tag by the function completing for the
tt(cvs) command to decide if the tt(stat) module should be used to
generate only names of modified files in the appropriate places.
)
item(tt(expand))(
Like tt(cursor), this style is used with the tt(paths) tag. If it is
set to `true', the partially typed path from the line will be
expanded as far as possible even if trailing pathname components can
not be completed.
)
item(tt(format))(
If this is set for the tt(descriptions) tag, its value is used as a
string to display above matches in completion lists. The sequence
`tt(%d)' in this string will be replaced with a short description of
what these matches are. This string may also contain the sequences to
specify output attributes, such as `tt(%b)' and `tt(%s)'.

For the tt(messages) tag, this defines a string used by some
completion functions to display messages. Here, the `tt(%d)' is
replaced with the message given by the completion function.

Finally, for the tt(warnings) tag, it is printed when no matches could 
be generated at all. In this case the `tt(%d)' is replaced with the
descriptions for the matches that were expected.
)
item(tt(glob))(
Like tt(complete), this is used by the tt(_expand) completer.

The value is used like the one for tt(complete) and if it evaluates to 
`tt(1)', globbing will be attempted on the words resulting from
substitution (see the tt(substitute) style) or the original string
from the line.
)
item(tt(group-name))(
The completion system can put different types of matches in different
groups which are then displayed separately in the list of possible
completions. This style can be use to give the names for these groups
for particular tags. For example, in command position the completion
system generates names of builtin and external commands, names of
aliases and shell functions and reserved words as possible
completions. To have the external commands and shell functions listed
separately, one can set:

example(compstyle '*:-command-:commands' group-name commands
compstyle '*:-command-:functions' group-name functions)

This also means that if the same name is used for different types of
matches, then those matches will be displayed together in the same
group.

If the name given is the empty string, then the name of the tag for
the matches will be used as the name of the group. So, to have all
different types of matches displayed separately, one can just set:

example(compstyle '*' group-name '')

All matches for which no group name is defined will be put in a group
named `tt(-default-)'.
)
item(tt(group-order))(
This style is to be used together with the tt(group-name) style. Once
different types of matches are put into different groups, this style
can be used to define in which order these groups should appear in the 
list. The strings in the value are taken as group names and the named
groups will be shown in the order in which their names appear in the
value. All groups whose names are not given in the value of this style 
will appear in the order defined by the function generating the
matches.

For example, to have names of builtin commands, shell functions and
external commands appear in this order when completing in command
position one would set:

example(compstyle '*:-command-' group-order builtins functions commands)
)
item(tt(groups))(
A style holding the names of the groups that should be completed. If
this is not set by the user, the group names from the YP database or
the file `tt(/etc/group)' will be used.
)
item(tt(hosts))(
A style holding the names of hosts that should be completed. If this
is not set by the user the hostnames in `tt(/etc/hosts)' will be used.
)
item(tt(hosts-ports))(
This style is used by commands that need or accept hostnames and
ports. The strings in the value should be of the form
`var(host)tt(:)var(port)'. These hostnames and ports are completed
depending on the information already on the line, so that if, for
example, the hostname is already typed, only those ports will be
completed for which pairs with the hostname from the line exist.
)
item(tt(hosts-ports-users))(
Like tt(hosts-ports) but used for commands like tt(telnet) and
containing strings of the form `var(host)tt(:)var(port)tt(:)var(user)'.
)
item(tt(ignored-suffixes))(
This style is used with the tt(files) tag and gives suffixes of
filenames to ignore. The matches ignored will only be completed when
there are no other matches.
)
item(tt(insert-unambiguous))(
This is used by the tt(_match) completer function. If it is set to
`true', the tt(_completer) will start menu
completion only if no unambiguous string could be generated that is at
least as long as the original string from the line.
)
item(tt(last-prompt))(
This is used by the main completion function tt(_main_complete) with
no particular context name. If it 
is `true', the cursor will always be moved back to the last prompt if
that is still visible, independent of the setting of the
tt(ALWAYS_LAST_PROMPT) option.
)
item(tt(list))(
This is used by the tt(_oldlist) completer, the
tt(_history_complete_word) bindable command and by the
tt(incremental-complete-word) widget.

For tt(_oldlist), if this is set to tt(always), then standard
widgets which perform listing will retain the current list of matches,
however they were generated.  If it is set to tt(never), this will not
be done (the behaviour without the tt(_oldlist) completer).  If it is
unset, or any other value, then the existing list of completions will
be displayed if it is not already; otherwise, the standard completion
list will be generated:  this is the default behaviour of
tt(_oldlist). However, if there is an old list and this style contains
the name of the completer function that generated the list, then the
old list will be used even if it was generated by a widget which does
not do listing.

For example, suppose you type tt(^Xc) to use the tt(_correct_word)
widget, which generates a list of corrections for the word under the
cursor.  Usually, typing tt(^D) would generate a standard list of
completions for the word on the command line, and show that.  With
tt(_oldlist), it will instead show the list of corrections already
generated.

As another example consider the tt(_match) completer: with the
tt(insert) style set to tt(unambig) it inserts only an
unambiguous prefix string if there is any. But since this may remove
parts of the original pattern, attempting completion again may result
in more matches than on the first attempt. But by using the
tt(_oldlist) completer and setting this style to tt(_match), the list of 
matches generated on the first attempt will be used again.

The tt(_history_complete_word) bindable command uses this style to
decide if the available matches should be shown.

When using the tt(incremental-complete-word) widget, this style says
if the matches should be listed on every key press (if they fit on the 
screen).
)
item(tt(list-arguments))(
Like the tt(arguments) style, but used when calling the tt(ps) command 
to generate the list to display.
)
item(tt(list-colors))(
If the tt(complist) module is used, this style can be used to set
color specifications as with the tt(ZLS_COLORS) and tt(ZLS_COLOURS)
parameters (see
ifzman(the section `The complist Module' in zmanref(zshmodules))\
ifnzman(noderef(The complist Module))\
).

If this style is set for the tt(default) tag, the strings in the value 
are taken as specifications that are to be used everywhere. If it is
set for other tags, the specifications are used only for matches of
the type described by the tag.

To be able to share the same specifications one has set up for the GNU
version of the tt(ls) command one can use:

example(compstyle '*:default' list-colors ${(s.:.)LS_COLORS})

And to get the default colors (which are the same as for the GNU
tt(ls) command) one should set the style to an empty value.
)
item(tt(local))(
This style is used by completion functions which generate URLs as
possible matches to add suitable matches when a URL points to a
local web server. Its value should consist of three strings: a
hostname, the path to the default web pages for the server and the
directory name used by a user placing web pages within their home
area.
)
item(tt(max-errors))(
This is used by the tt(_approximate) completer function to determine
the maximum number of errors to accept. The completer will try to
generate completions by first allowing one error, then two errors, and
so on, until either a match was found or the maximum number of errors
given by this style has been reached.

If the value for this style contains the string `tt(numeric)', the 
completer function will take any numeric argument as the
maximum number of errors allowed. For example, with

example(compstyle ':approximate' accept 2 numeric)

two errors will be allowed if no numeric argument is given. However,
with a numeric argument of six (as in `tt(ESC-6 TAB)'), up to six
errors are accepted.  Hence with a value of `tt(0 numeric)', no correcting
completion will be attempted unless a numeric argument is given.

If the value contains the string `tt(not-numeric)', tt(_approximate)
will em(not) try to generate corrected
completions when given a numeric argument, so in this case the number given
should be greater than zero.  For example, `tt(2 not-numeric)' specifies that
correcting completion with two errors will usually be performed, but if a
numeric argument is given, correcting completion will not be performed.
)
item(tt(menu))(
This is used by the tt(_expand) completer. If it is unset or set to
an empty value, the words resulting from expansion (if any) will
simply be inserted in the command line, replacing the original
string. However, if this style is set to a non-empty value, the user
can cycle through the expansion as in menucompletion. Unless the value
contains the string `tt(only)', the user will still be offered all
expansions at once as one of the strings to insert in the command
line; normally, this possibility is offered first, but if the value
contains the string `tt(last)', it is offered last. Also, if the
value contains the string `tt(sort)', the expansions will be sorted
alphabetically, normally they are kept in the order the expansion
produced them in. And finally, if the value contains the string
`tt(show-all)', the string of all words will be shown in the list of
expansions.

The tt(_oldlist) completer uses this, too. Here it controls how menu
completion behaves when a completion has already been inserted and the
user types a standard completion key type such as tt(TAB). The default
behaviour of tt(_oldlist) is that menu completion always continues
with the existing list of completions.  If this style is set to
`false', however, a new completion is started if the old list was
generated by a different completion command (the behaviour without the 
tt(_oldlist) completer).

For example, suppose you type tt(^Xc) to generate a list of corrections,
and menu completion is started in one of the usual ways.  Usually, typing
tt(TAB) at this point would start trying to complete the line as it now
appears.  With tt(_oldlist), it will instead continue to cycle through the
list of completions.
)
item(tt(original))(
In the tt(_approximate) completer this style is used to specify
whether the original string on which correcting completion was
attempted is to be included in the list of possible corrections. If it
is set to any non-empty value, the original string will be offered
when cycling through the completions. Normally it will appear as the
first string, so that the command line does not change immediately;
consecutive completion attempts will cycle through the corrected
strings.  If the value for this style contains the string `tt(last)',
the original string will be the last one in the list, so that it
appears just before wrapping around to the first corrected string
again.  Also, if the value contains the string `tt(always)', the
original string will always be included; normally it is included only
if more than one possible correction was generated. And finally, if
the value contains the string `tt(show)', the original string will
be shown in the list of corrections.

For the tt(_expand) completer function, if this is set to an non-empty
string, the original string from the line will be included in the list
of strings the user can cycle through as in a menucompletion. If the
value contains the string `tt(last)', the original string will
appear as the last string, with other values it is inserted as the
first one (so that the command line does not change
immediately). Also, if the value contains the string `tt(show)',
the original string will be shown in the list of expansions.

Finally, for the tt(_match) completer, if this style is set to
`tt(only)', it will try to generate matches without inserting a
`tt(*)' at the cursor position. If set to any other non-empty value,
it will first try to generate matches without inserting the `tt(*)'
and if that yields no matches, it will try again with the `tt(*)'
inserted.
)
item(tt(path))(
This is used together with the the tt(urls) tag by completion
functions that generate URLs as possible matches. It should be set to
the path of a directory containing sub-directories named like
`tt(http)', `tt(ftp)', `tt(bookmark)', and so on. These
sub-directories should contain files and other sub-directories whose
pathnames are possible completions after the initial `tt(http://)',
`tt(ftp://)', etc. See the description in the file tt(_urls) in the
tt(User) sub-directory of the completion system for more information.

Also, the function that completes color names uses this style with the 
tt(colors) tag. Here, the value should be the pathname of a file
containing color names in the format of an X11 tt(rgb.txt) file.
)
item(tt(ports))(
A style holding the service names of ports to complete. If this is
not set by the user, the service names from `tt(/etc/services)' will
be used.
)
item(tt(prefix-hidden))(
This is used when matches with a common prefix are added (e.g. option
names). If it is `true', this prefix will not be shown in the list of
matches.
)
item(tt(prefix-needed))(
This, too, is used for matches with a common prefix. If it is set to
`true' this common prefix has to be typed by the user to generate the
matches. E.g. for options this means that the `tt(-)', `tt(+)', or
`tt(--)' has to be on the line to make option names be completed at
all.
)
item(tt(prompt))(
The tt(approximate) completer uses the value of this style as a string
to be displayed on top of the corrected strings generated when cycling
through them. This string may contain the control sequences `tt(%n)',
`tt(%B)', etc. known from the `tt(-X)' option of tt(compadd). Also,
the sequence `tt(%e)' will be replaced by the number of errors
accepted to generate the corrected  strings.

The tt(_expand) completer uses it for the same purpose, but here the
sequence `tt(%o)' will be replaced by the original string from the
line.

Also, the tt(incremental-complete-word) widget shows the value of this
style in the status line during incremental completion. The sequence
`tt(%u)' is replaced by the unambiguous part of all matches if there
is any and it is different from the word on the line. A `tt(%s)' is
replaced with `tt(-no match-)', `tt(-no prefix-)', or an empty string
if there is no completion matching the word on the line, if the
matches have no common prefix different from the word on the line or
if there is such a common prefix, respectively. The sequence `tt(%c)'
is replaced by the name of the completer function that generated the
matches (without the leading underscore). Finally, `tt(%n)' is
replaced by the number of matches generated, `tt(%a)' is replaced by
an empty string if the matches are in the normal set (i.e. the one
without file names with one of the suffixes from the tt(fignore)
array) and with `tt( -alt-)' if the matches are in the alternate set,
and if the tt(list) style is set, `tt(%l)' is replaced by `tt(...)' if
the list of matches is too long to fit on the screen and with an empty
string otherwise. If tt(incremental_list) is not set or set to an
empty string, `tt(%l)' will always be removed.
)
item(tt(remove-all-dups))(
The tt(_history_complete_word) bindable command uses this to decide if 
all duplicate matches should be removed, rather than just consecutive
duplicates.
)
item(tt(sort))(
If set to `true', completion functions that generate words from the
history as possible matches sort these words alphabetically instead of
keeping them in the order in which they appear in the history (from
youngest to oldest).
)
item(tt(stop))(
If set to a non-empty string, the tt(_history_complete_word) bindable
command will always insert matches as if menu-completion were started
and it will stop when the last match is inserted. If this style is set
to tt(verbose) a message will be displayed when the last match is reached.
)
item(tt(strings))(
This is used with the tt(jobs) tag. If it is `true', the completions
will use the shortest unambiguous strings of the jobs' command lines
instead of the job numbers.
)
item(tt(substitute))(
If this is unset or set to the empty string, the tt(_expand) completer
will first try to expand all substitutions in the string (such as
`tt($LPAR()...RPAR())' and `tt(${...})'). If this is set to an
non-empty string it should be an expression usable inside a `tt($((...)))'
arithmetical expression. In this case, expansion of substitutions will
be done if the expression evaluates to `tt(1)'. For example, with

example(compstyle ':expand' substitute '${NUMERIC:-1} != 1')

substitution will be performed only if given an explicit numeric
argument other than `tt(1)', as by typing `tt(ESC 2 TAB)'.
)
item(tt(users))(
This may be set to a list of names that should be completed whenever 
a username is needed. If it is not set or the string on the line
doesn't match any of the strings in this list, all usernames will be
completed.
)
item(tt(users-hosts))(
The values of this style should be of the form
`var(user)tt(:)var(host)'. It is used for commands that need pairs of
user- and hostnames. For such commands, only the pairs from this style 
are used and if, for example, the hostname is already typed, then only 
the hostnames for which there is a pair with that username is defined.

If set for the tt(my-accounts) tag, this is used for commands such as
tt(rlogin) and tt(ssh). I.e. the style should contain the names of the 
user's own accounts. With the tt(other-accounts) this is used for
commands such as tt(talk) and tt(finger) and should contain other
people's accounts. Finally, this may also used by some commands with
the tt(accounts) tag.
)
item(tt(verbose))(
This is used in several contexts to decide if only a simple or a
verbose list of matches should be generated. For example some commands 
show descriptions for option names if this style is true.
)
item(tt(word))(
To find out if listing should be performed on its own, the tt(_list)
completer normally compares the contents of the line with the contents
the line had at the time of the last invocation. If this style is set to
`true', comparison is done using only the current word. In this case,
attempting completion on a word equal to the one when completion was called
the last time will not delay the generation of matches.
)
enditem()

texinode(Control Functions)(Bindable Commands)(Completion System Configuration)(Completion System)
sect(Control Functions)
cindex(completion system, choosing completers)

The initialization script tt(compinit) redefines all the widgets
which perform completion to call the supplied widget function
tt(_main_complete). This function acts as a wrapper calling the
so-called `completer' functions that generate matches. If
tt(_main_complete) is called with arguments, these are taken as the
names of completer functions to be called in the order given.  If no
arguments are given, the set of functions to try is taken from the
tt(completer) style. For example, to use normal completion and
correction if that doesn't generate any matches:

example(compstyle '*' completer _complete _correct)

after sourcing tt(compinit). The default value for this style set up
in tt(compinit) is `tt(_complete)', i.e. normally only ordinary
completion is tried. The tt(_main_complete) function uses the return
value of the completer functions to decide if other completers should be
called. If the return value is zero, no other completers are tried and the
tt(_main_complete) function returns.

Immediately before returning the tt(_main_complete) function calls all
functions whose names are given in the tt(comppostfuncs) array and
then resets it to an empty array. This can be used by completion
functions or by other ZLE widgets calling completion to register code
that is to be executed after all matches have been added.

The widget function tt(_main_complete) also uses the style 
tt(last-prompt). If this is set to `true', the cursor is moved up
to the last prompt after printing a list of matches even if a numeric
argument was given.

The following completer functions are contained in the distribution (users
may write their own):

cindex(completion system, completers)
startitem()
item(tt(_complete))(
This completer generates all possible completions in a context-sensitive
manner, i.e. using the tt(compdef) function
explained above and the current settings of all special parameters.

To complete arguments of commands, tt(_complete) uses the utility function
tt(_normal), which is in turn responsible for finding the particular
function; it is described below.  Various contexts of the form
tt(-)var(context)tt(-), as mentioned above for the tt(#compdef) tag, are
handled specially.  These are:

startitem()
item(tt(-equal-))(
for completion after an equal sign, other than one occurring in a
shell-variable assignment.
)
item(tt(-tilde-))(
for completion after a tilde (`tt(~)') character, but before a slash.
)
item(tt(-redirect-))(
for completion after a redirection operator.
)
item(tt(-math-))(
for completion inside mathematical contexts, such as
`tt(LPAR()LPAR())...tt(RPAR()RPAR())'.
)
item(tt(-subscript-))(
for completion inside subscripts.
)
item(tt(-value-))(
for completion on the right hand side of an assignment.
)
item(tt(-array-value-))(
for completion on the right hand side of an array-assignment
(`tt(foo=LPAR()...RPAR())').
)
item(tt(-condition-))(
for completion inside conditions (`tt([[...]])').
)
item(tt(-parameter-))(
for completing the name of a parameter expansion (`tt($...)').
)
item(tt(-brace-parameter-))(
for completing the name of a parameter expansion within braces
(`tt(${...})').
)
item(tt(-first-))(
for adding completions before any other other completion functions are
tried; if this
function sets the tt(_compskip) parameter to `tt(all)', no other
completion functions will be called, if it is set to a string
containing `tt(patterns)', no pattern completion functions will be
called, and if it is set to a string containing `tt(default)' the
function for the `tt(-default-)' context will not be called, but
functions defined for commands will.
)
item(tt(-default-))(
for generating completions when no special completion function is used.
)
item(tt(-command-))(
for completing in a command position.
)
enditem()

Default implementations are supplied for each of these
contexts, in most cases named after the context itself
(e.g. completion for the `tt(-tilde-)' context is done by the function 
named `tt(_tilde)').

Before trying to find a function for a specific context, tt(_complete) 
checks if the parameter `tt(compcontext)' is set to a non-empty
value. If it is, the value is taken as the name of the context to use
and the function defined for that context will be called.

Note that the widget functions from the distribution that call the
completion code (namely, the tt(incremental-complete-word) and the
tt(predict-on) widgets) set up their top-level context name before
calling completion. This allows one to define different sets of
completer functions for normal completion and for these widgets. For
example, to use completion, approximation and correction for normal
completion, completion and correction for incremental completion and
only completion for prediction one could use:

example(compstyle '*' completer _complete _correct _approximate
compstyle ':incremental' completer _complete _correct
compstyle ':predict' completer _complete)
)
item(tt(_approximate))(
This completer function uses the tt(_complete) completer to generate
a list of strings for the context the cursor is currently in, allowing 
you to specify a maximum number of errors:  see the description of
approximate matching in
ifzman(\
zmanref(zshexpn)
)\
ifnzman(\
noderef(Filename Generation)
)\
for how errors are
counted. The resulting list of corrected and completed strings is then
presented to the user. The intended use of this completer function is to
try after the normal tt(_complete) completer by setting:

example(compstyle '*' completer _complete _approximate)

This will give correcting completion if and only if
normal completion doesn't yield any possible completions. When
corrected completions are found, the completer will normally start
menucompletion allowing you to cycle through these strings.

The exact behavior of this completer can be changed by using the
styles tt(max-errors), tt(original), tt(prompt), and tt(insert), see
ifzman(the section `Completion System Configuration' above)\
ifnzman(noderef(Completion System Configuration)).

Like all completers tt(_approximate) uses its name without the
undersccore as the top-level context name. Once it has started trying
to generate matches, it will add another context name component
containing the number of errors accepted in this attempt. So on the
first try the context name starts with `tt(:approximate:1)', on the
second try with `tt(:approximate:2)', and so on.
)
item(tt(_correct))(
Generate corrections (but not completions) for the current word; this is
similar to spell-checking.  This calls tt(_approximate) but uses a
different top-level context name.

For example, with:

example(compstyle '*' completer _complete _correct _approximate
compstyle ':correct' accept 2 not-numeric'
compstyle ':approximate' accept 3 numeric)

correction will accept up to two errors. If a numeric argument is
given, correction will not be performed, but correcting completion
will be, and will accept as many errors as given by the numeric
argument. Without a numeric argument, first correction and then
correcting completion will be tried, with the first one accepting two
errors  and the second one accepting three errors.

This completer function is intended to be used without the
tt(_approximate) completer or, as in the example, just before
it. Using it after the tt(_approximate) completer is useless since
tt(_approximate) will at least generate the corrected strings
generated by the tt(_correct) completer -- and probably more.
)
item(tt(_match))(
This completer is intended to be used after the tt(_complete)
completer. It allows one to give patterns on the command line and
to complete all strings matching these patterns from the set of
possible completions for the context the cursor is in, without having
to set the tt(GLOB_COMPLETE) option.

Normally this will be done by taking the pattern from the line,
inserting a `tt(*)' at the cursor position and comparing the resulting
pattern with the possible completions generated. However, if the
tt(original) style has a value of `tt(only)', no `tt(*)' will be
inserted. If tt(original) has any other non-empty string as its
value, this completer will first try to generate matches without, then
with a `tt(*)' inserted at the cursor position.

The generated matches will be offered in a menucompletion unless the
tt(insert) style is set to a string starting with `tt(unambig)'. In
this case menucompletion will only be started if no unambiguous string
could be generated that is at least as long as the original string.

Note that the matcher specifications defined globally or used by the
completion functions will not be used.
)
item(tt(_expand))(
This completer function does not really do completion, but instead
checks if the word on the command line is eligible for expansion and,
if it is, gives detailed control over how this expansion is done. When 
using this, one should not use the tt(expand-or-complete) widget, but
instead use tt(complete-word), as otherwise tt(expand-or-complete)
will expand the string on the line before the completion widget is
called. Also, this completer should be called before the tt(_complete) 
completer function.

Control over how the expanded string will be treated is possible with the 
tt(substitute), tt(glob), tt(menu), tt(original), and tt(prompt)
styles, see
ifzman(the section `Completion System Configuration' above)\
ifnzman(noderef(Completion System Configuration)).

In a different mode selected by the tt(completions) style, all
em(completions) generated for the string on the line are inserted.
)
item(tt(_list))(
This completer allows one to delay the insertion of matches until
completion is attempted a second time without the word on the line
being changed. On the first attempt, only the list of matches will be
shown. Styles used are tt(condition) and tt(word), see
ifzman(the section `Completion System Configuration' above)\
ifnzman(noderef(Completion System Configuration)).
)
item(tt(_menu))(
This completer is a simple example function implemented to show how
menucompletion can be done in shell code. It should be used as the
first completer and has the effect of making the code perform
menucompletion. Note that this is independent of the setting of the
tt(MENU_COMPLETE) option and does not work with the other
menucompletion widgets such as tt(reverse-menu-complete), or
tt(accept-and-menu-complete).
)
item(tt(_oldlist))(
This completer controls how the standard completion widgets behave
when there is an existing list of completions which may have been
generated by a special completion (i.e. a separately-bound completion
command).  It should appear in the list of completers before any of
the widgets which generate matches.  It uses two styles: tt(list) and
tt(menu), see
ifzman(the section `Completion System Configuration' above)\
ifnzman(noderef(Completion System Configuration)).
)
enditem()

texinode(Bindable Commands)(Completion Functions)(Control Functions)(Completion System)
sect(Bindable Commands)
cindex(completion system, bindable commands)

In addition to the context-dependent completions provided, which are
expected to work in an intuitively obvious way, there are a few widgets
implementing special behaviour which can be bound separately to keys.  The
following is a list of these and their default bindings.

startitem()
item(tt(_bash_completions))(
This function is used by two widgets, tt(_bash_complete-word) and
tt(_bash_list-choices).  It exists to provide compatibility with
completion bindings in bash.  The last character of the binding determines
what is completed: `tt(!)', command names; `tt($)', environment variables;
`tt(@)', host names; `tt(/)', file names; `tt(~)' user names.  In bash, the
binding preceeded by `tt(\e)' gives completion, and preceeded by `tt(^X)'
lists options.  As some of these bindings clash with standard zsh
bindings, only `tt(\e~)' and `tt(^X~)' are bound by default.  To add the
rest, the following should be added to tt(.zshrc) after tt(compinit) has
been run:

example(for key in '!' '$' '@' '/' '~'; do
  bindkey "\e$key" _bash_complete-word
  bindkey "^X$key" _bash_list-choices
done)

This includes the bindings for `tt(~)' in case they were already bound to
something else; the completion code does not override user bindings.
)
item(tt(_correct_filename (^XC)))(
Correct the filename path at the cursor position.  Allows up to six errors
in the name.  Can also be called with an argument to correct
a filename path, independently of zle; the correction is printed on
standard output.
)
item(tt(_correct_word) (^Xc))(
Performs correction of the current argument using the usual contextual
completions as possible choices. This uses the top-level context name
`tt(:correct-word)' and then calls the tt(_correct) completer.
)
item(tt(_expand_word (^Xe)))(
Performs expansion on the current word:  equivalent to the standard
tt(expand-word) command, but using the tt(_expand) completer. Before
calling it, the top-level context name is set to `tt(:expand-word)'.
)
item(tt(_history_complete_word) (\e/))(
Complete words from the shell's command history.
)
item(tt(_most_recent_file (^Xm)))(
Complete the name of the most recently modified file matching the pattern
on the command line (which may be blank).  If given a numeric argument
var(N), complete the var(N)th most recently modified file.  Note the
completion, if any, is always unique.
)
item(tt(_read_comp (^X^R)))(
Prompt the user for a string, and use that to perform completion on the
current word.  There are two possibilities for the string.  First, it can
be a set of words beginning `tt(_)', for example `tt(_files -/)', in which
case the function with any arguments will be called to generate the
completions.  Unambiguous parts of the function name will be completed
automatically (normal completion is not available at this point) until a
space is typed.

Otherwise, any other string, will be passed as arguments to
tt(compadd) and should hence be an expression specifying what should
be completed.

A very restricted set of editing commands is available when reading the
string:  `tt(DEL)' and `tt(^H)' delete the last character; `tt(^U)' deletes
the line, and `tt(^C)' and `tt(^G)' abort the function, while `tt(RET)'
accepts the completion.  Note the string is used verbatim as a command
line, so arguments must be quoted in accordance with standard shell rules.

Once a string has been read, the next call to tt(_read_comp) will use the
existing string instead of reading a new one.  To force a new string to be
read, call tt(_read_comp) with a numeric argument.
)
item(tt(_complete_help (^Xh)))(
This widget displays information about the context names and tags used 
when completing at the current cursor position.
)
enditem()

texinode(Completion Functions)(Completion Directories)(Bindable Commands)(Completion System)
sect(Utility Functions)
cindex(completion system, utility functions)

Descriptions follow for utility functions that may be
useful when writing completion functions.  Most of these reside in the
tt(Core) subdirectory except where noted. Like the example 
functions for commands in the distribution, the utility functions
generating matches all follow the convention of returning zero if they
generated completions and non-zero if no matching completions could be 
added.

startitem()
findex(_funcall)
item(tt(_funcall) var(return) var(name) [ var(args) ... ])(
If a function var(name) exists, it is called with the arguments
var(args). Unless it is the empty string or a single hyphen,
var(return) is taken as the name of a parameter and the return status
from the called function is stored in it.
The return value of tt(_funcall) itself is zero if the function
var(name) exists and was called and non-zero otherwise.
)
item(tt(_compalso))(
This function looks up the definitions for the context and command
names given as arguments and calls the handler functions for them if
there is a definition (given with the tt(compdef) function). For
example, the function completing inside subscripts might use
`tt(_compalso -math-)' to include the completions generated for
mathematical environments.
)
item(tt(_normal))(
This function is used for normal command completion.  If
completion is attempted on the first word, command names are
completed. Otherwise, the arguments are completed by calling the
functions defined for this command, including those functions defined
for patterns matching the command name. This function can also be
called by other completion functions if they have to complete a range
of words as a separate command. For example, the function to complete after
the pre-command specifiers such as tt(nohup) removes the first word from
the tt(words) array, decrements the tt(CURRENT) parameter, then calls this
function.

When calling a function defined for a pattern, this function also
checks if the parameter tt(_compskip) is set and uses the value in the 
same way it is used after calling the completion function for the
tt(-first-) context. With this 
one can write a pattern completion function that keeps other functions 
from being tried simply by setting this parameter to any value.
)
item(tt(_description))(
This function gets two or three arguments: a group name,
the name of an array and a
string. It tests if the style tt(format) for the tt(descriptions) tag is
set and if it is, it stores some options in the array that can then be 
given to the tt(compadd) builtin command to make the
value of the tt(format) style for the tt(descriptions) tag (with the
sequence `tt(%d)' replaced by the string given as the last argument)
be displayed above the matches added. These options also will make
sure that the matches are placed in a separate group if the style
tt(group) for the tt(matches) tag is set to `true'. The first argument 
will be used as the name of the group and should in most cases be the
name of a tag. Normally a sorted
group will be used for this (with the `tt(-J)' option), but if a
option starting with `tt(-V)' or `tt(-J)' is given, that option will
be included in the array, so that it is possible to make the group
unsorted by giving the option `tt(-V)', `tt(-V1)', or `tt(-V2)'.

In most cases, this function will be used like this:

example(local expl
_description expl file  # same as `files expl file'
compadd "$expl[@]" - "$files[@]")
)
item(tt(_message))(
This function takes one argument which is used like the second
argument to the tt(_description) function. However, the resulting
string will always be shown, not only if some matches were
generated. This is useful to display help texts in places where no
completions can be generated automatically.

This function also uses the tt(format) style for the tt(messages) tag in
preference to the tt(format) style for the tt(descriptions) tag. The
latter is used only if the former is unset.
)
item(tt(_tags))(
If called with arguments, these are taken as the names of the tags for 
the types of matches the calling completion function can generate in
the current context. These tags are stored internally and sorted by
calling the tt(_sort_tags) function. Following calls to this function
without arguments from the same function will then select the first,
second, etc. set of tags requested by the user. To test if a certain
tag should be tried, the tt(_requested) function has to be called (see 
below).

The return value is zero if at least one of the tags is requested and
non-zero otherwise. 

This function also accepts the tt(-C) option followed by a name. This
name is temporarily (i.e. not visible outside tt(_tags)) appended
(with a colon before it) to the contents of the tt(curcontext)
parameter. This allows to make tt(_tags) and tt(_sort_tags) use a
more specific context name without having to change and reset the
tt(curcontext) parameter (which would otherwise have the same effect).
)
item(tt(_requested))(
A function that uses tt(_tags) to register tags and then calls it to
loop over the requested sets of tags should call this function to
check if a certain tag is currently requested. This normally has to be 
done in a loop such as:

example(_tags foo bar baz
while _tags; do
  if _requested foo; then
    ...
  fi
  ... # test other tags
  ... # exit loop if matches were generated
done)

So, the first argument for tt(_requested) is used as the name of a tag 
and if that tag is currently requested, the return value is zero (and
non-zero otherwise).

If more than one argument is given, tt(_requested) calls the
tt(_description) function with all arguments and if the first argument 
is a option string starting with tt(-J) or tt(-V), the argument after
it is taken as the name of the tag.
This is often useful to do both the testing of the tag and
getting the description for the matches one is about to add at
once. E.g.:

example(local expl ret=1
_tags foo bar baz
while _tags; do
  _requested foo expl 'description' &&
      compadd "$expl[@]" foobar foobaz && ret=0
  ...
  (( ret )) || break
done)
)
item(tt(_wanted))(
In many contexts only one type of matches can be generated but even
then it should be tested if the tag representing those matches is
requested by the user. This function makes that easier.

Like tt(_requested) it gets arguments as for tt(_description).
With the tag it calls tt(_tags) and if that returns zero 
(i.e. the tag is requested by the user) it calls tt(_description). So, 
if you want to offer only one tag and immediatly want to use the
description built, you can just do:

example(_wanted tag expl 'description' &&
    compadd "$expl[@]" matches...)

Note that you only need to use this function if you need a
description. If, for example, you use one of the utility functions
that adds a description itself, you only need to call tt(_tags) as in:

example(_tags tag && _helper)
)
item(tt(_alternative))(
This function is useful if you offer multiple tags and building the
matches for them is easy enough. It basically implements a loop like
the one described above.

The tags to use and what to do if the tags are requested are described 
using the arguments which are of the form:
`var(tag)tt(:)var(descr)tt(:)var(action)'. The var(tag)s are offered
using tt(_tags) and if the tag is requested, the var(action) is
executed with the given var(descr) (description). The var(action)s
supported are those used by the tt(_arguments) function (described
below), without the `tt(->)var(state)' form.

For example, the var(action) may be a simple function call. With that
one could do:

example(_alternative \
    'users:user:_users' \
    'hosts:host:_hosts')

to offer usernames and hostnames as possible matches (which are
generated by the tt(_users) and tt(_hosts) functions respectively).

Like tt(_tags) this function supports the tt(-C) option to give an
additional context name component.
)
item(tt(_style))(
This function is used to look up the values of styles defined by the
user. In its simplest form, it is called with two arguments: a tag and 
a style-name. The tag (if non-empty) is temporarily appended to the
current context name (preceded by a colon) and the patterns defined by 
the user with the tt(compstyle) function will be compared to that
combined name. If any of those pattern matches the name and the given
style is defined for it and its boolean value is `true' (i.e. its
value is one of `tt(true)', `tt(on)', `tt(yes)', and `tt(1)'), tt(_style)
returns zero and non-zero otherwise. If you want to test the style not 
only for a boolean value, you can give a third argument which is then
used as a pattern and tt(_style) returns zero if the pattern matches
the value defined for the style.

If you want to retrieve the value defined for the style, you can use
one of the options tt(-b) (to retrieve it as a boolean value, i.e. one 
of tt(yes) or tt(no)), tt(-s) (to get it as a scalar, i.e. a string
concatenated from the value strings defined by the user, separated by
spaces), tt(-a) (to get it as an array), and tt(-h) (to get it as an
associative array; in this case the first, third, etc. strings from the 
value are used as the keys and the others as their values). In each of
these cases the arguments after the option are the tag, the style-name
and the name of the parameter into which the result will be stored.

For example, to test if the tt(description) style is set to `true' for 
the current context and the tag tt(foo):

example(if _style foo description; then
  ... # style is true
fi)

And to get the value of the tt(path) style for the tag tt(foo) as an
array into the parameter tt(tmp):

example(local tmp
_style -a foo path tmp)

In any case, the return value of this function is zero, if a
definition for the style was found and non-zero if no definition was
found.
)
item(tt(_describe))(
This function can be used to add options or values with descriptions
as matches. The first argument is taken as a string to display above
the matches if the tt(format) style for the tt(descriptions) tag is set.

After this one or two names of arrays followed by options to give
to tt(compadd) must be given. The first array contains the possible
completions with their descriptions (with the description separated
by a colon from the completion string). If the second array is given,
it should have the same number of elements as the first one and these
elements are added as possible completions instead of the strings from 
the first array. In any case, however, the completion list will show
the strings from the first array.

Any number of array/option sequences may be given separated by
`tt(-)tt(-)'. This allows one to display matches together that need
to be added with different options for tt(compadd).

Before the first argument, two options may be given. A `tt(-o)' says
that the matches added are option names. This will make tt(_describe)
use the tt(prefix-hidden), tt(prefix-needed) and tt(description) styles
to find out if the strings should be added at all and if the
descriptions should be shown. Without the `tt(-o)' option, only the
tt(description) style is used.
)
item(tt(_multi_parts))(
This function gets two arguments: a separator character and an
array.  As usual, the array may be either the
name of an array parameter or a literal array in the form
`tt(LPAR()foo bar)tt(RPAR())' (i.e. a list of words separated by white 
space in parentheses). With these arguments, this function will
complete to strings from the array where the parts separated by the
separator character are completed independently. For example, the
tt(_tar) function from the distribution caches the pathnames from the
tar file in an array and then calls this function to complete these
names in the way normal filenames are completed by the
tt(_path_files) function.

Like other utility functions, this function accepts the `tt(-V)',
`tt(-J)', `tt(-X)', `tt(-M)', `tt(-P)', `tt(-S)', `tt(-r)', `tt(-R)', and
`tt(-q)' options and passes them to the tt(compadd) builtin.
)
item(tt(_sep_parts))(
This function gets as arguments alternating arrays and separators.
The arrays specify completions for parts of strings to be separated by the
separators. The arrays may be the names of array parameters or
a quoted list of words in parentheses. For example, with the array
`tt(hosts=(ftp news))' the call `tt(_sep_parts '(foo bar)' @ hosts)' will
complete the string  `tt(f)' to `tt(foo)' and the string `tt(b@n)' to
`tt(bar@news)'.

This function passes the `tt(-V)', `tt(-J)', `tt(-X)', `tt(-M)', `tt(-P)',
`tt(-S)', `tt(-r)', `tt(-R)', and `tt(-q)' options and their arguments
to the tt(compadd) builtin used to add the matches.
)
item(tt(_path_files) and tt(_files))(
The function tt(_path_files) is used throughout the shell code
to complete filenames. It allows completion of partial paths. For
example, the string `tt(/u/i/s/sig)' may be completed to
`tt(/usr/include/sys/signal.h)'.  The option `tt(-/)' specifies that
only directories should be completed. The option `tt(-g) var(pattern)' 
says that only files matching the var(pattern) should be completed,
and the `tt(-f)' option, which is the default, completes all
filenames. The option `tt(-W) var(paths)' may be used to specify path
prefixes that are to be prepended to the string from the line to
generate the filenames but that should not be inserted in the line or
shown in a completion listing. The var(paths) may be the name of an
array parameter or a literal list of paths enclosed in parentheses.
Additionally, the `tt(-F)'
option from the tt(compadd) builtin is supported, giving direct control
over which filenames should be ignored. If no such option is given,
the tt(fignore) parameter is used.

The function tt(_files) calls tt(_path_files) with all the arguments
it was passed and, if that generated no matches, calls tt(_path_files) again
without any tt(-g) or tt(-/) option, thus generating all filenames.

These functions also accept the `tt(-J)', `tt(-V)', `tt(-X)',
`tt(-M)', `tt(-P)', `tt(-S)', `tt(-q)', `tt(-r)', and `tt(-R)' options
from the tt(compadd) builtin.

Finally, the tt(_path_files) function supports two styles.
startitem()
item(tt(expand))(
If this is set to a string containing `tt(prefix)', the partially
typed path from the line will be expanded as far as possible even if
trailing pathname components can not be completed. If it contains the
substring `tt(suffix)' and normal (non-menu-) completion is used,
matching names for components after the first ambiguous one will be
added, too. This means that the resulting string is the longest
unambiguous string possible, but if menu-completion is started on the
list of matches generated this way (e.g. due to the option
tt(AUTO_MENU) being set), this will also cycle through the names
of the files in pathname components after the first ambiguous one.
)
item(tt(cursor))(
If this is set to `true', the cursor will be left after the first
ambiguous pathname component even when menucompletion is used.
)
enditem()
)
item(tt(_parameters))(
This should be used to complete parameter names if you need some of the
extra options of tt(compadd). All arguments are passed unchanged to
the tt(compadd) builtin.
)
item(tt(_options))(
This can be used to complete option names. It uses a matching
specification that ignores a leading `tt(no)', ignores underscores and 
allows the user to type upper-case letters, making them match their
lower-case counterparts. All arguments passed to this function are
propagated unchanged to the tt(compadd) builtin.
)
item(tt(_set_options) and tt(_unset_options))(
These functions complete only set or unset options, with the same
matching specification used in the tt(_options) function.

Note that you need to uncomment a few lines in the tt(_main_complete)
function for these functions to work properly. The lines in question
are used to store the option settings in effect before the completion
widget locally sets the options it needs.
)
item(tt(_arguments))(
This function resides in the tt(Base) subdirectory of the example
completion system because it is not used by the core system.

This function can be used to complete words on the line by simply
describing the arguments the command on the line gets. The description 
is given as arguments to this function, with each argument describing
one option or normal argument of the command. The descriptions
understood are:

startitem()
item(var(n)tt(:)var(message)tt(:)var(action))(
This describes the var(n)'th normal argument. The var(message) will be 
printed above the matches generated and the var(action) says what can
be completed in this position (see below). If there are two colons
before the var(message), this describes an optional argument.
)
item(tt(:)var(message)tt(:)var(action))(
Like the previous one, but describing the em(next) argument. I.e. if
you want to describe all arguments a command can get, you can leave
out the numbers in the description and just use this form to describe
them one after another in the order they have to appear on the line.
)
item(tt(*:)var(message)tt(:)var(action))(
This describes how arguments are to be completed for which no
description with one of the first two forms was given. This also means 
that any number of arguments can be completed.

If there are two colons before the var(message) (as in
`tt(*::)var(message)tt(:)var(action)') the tt(words) special array and 
the tt(CURRENT) special parameter will be restricted to only the
normal arguments when the var(action) is executed or evaluated. With
three colons before the var(message) they will be restricted to only
the normal arguments covered by this description.
)
item(var(opt-spec)[var(description) ...])(
This describes an option and (if at least one var(description) is
given) the arguments that have to come after the option. If no
var(description) is given, this will only be used to offer the option
name as a possible completion in the right places. Each
var(description) has to be of the form
`tt(:)var(message)tt(:)var(action)' or
`tt(::)var(message)tt(:)var(action)', where the second form describes
an optional argument and the first one describes a mandatory argument.
The last description may also be of the form
`tt(:*:)var(message)tt(:)var(action)' or
`tt(:*)var(pattern)tt(:)var(message)tt(:)var(action)'. These describe
multiple arguments. In the first form all following words on the line
are to be completed as described by the var(action), in the second
form all words up to a word matching the given var(pattern) are to be
completed using the var(action). The `tt(*)' or the var(pattern) may
also be separated from the var(message) by two or three colons. With
two colons the tt(words) special array and the tt(CURRENT) special
parameter are modified to refer only to the words after the option
(with two colons) or to the words covered by this description (with
three colons) during the execution or evaluation of the
var(action). Note that only one such `tt(:*)'-specification is useful
and no other argument specification may be given after it.

In the simplest form the var(opt-spec) is just the option name
beginning with a minus or a plus sign, such as `tt(-foo)'. In this
case, the first argument for the option (if any) has to come as a
separate word directly after the option and the option may appear only 
once on the line (and if it is already on the line, the option name
will not be offered as a possible completion again). If the first
argument for the option has to come directly after the option name
em(in the same word), a minus sign should be added to the end of the
var(opt-spec), as in `tt(-foo-)'. If the first argument may be given
in one string with the option name, but may also be given as a
separate argument after the option, a plus sign should be used
instead. If the argument may be given as the next string or in same
string as the option name but separated by it from an equal sign, a
`tt(=)' should be used instead of the minus or plus sign.

If the option may be given more than once, a star
(`tt(*)') has to be added in front of the var(opt-spec) because
otherwise it is not offered as a possible completion again if it is
already on the line.

An var(opt-spec) may also contain a list of other option names with
which the option described is mutually exclusive. Such a list is given 
in parentheses at the beginning, as in `tt((-two -three)-one:...)'. In 
this example, the options `tt(-two)' and `tt(-three)' will not be
offered as possible completions if the option `tt(-one)' is on the
line. Also, the list may contain a single colon as one of its elements 
to specify that the descriptions for normal (non-option-) arguments
should not be used if the option described is on the line.

Finally, the var(opt-spec) may contain a explanation string. This is
given in brackets at the end, as in `tt(-q[query operation])'. The
tt(description) style for the tt(options) tag is used to decide if these
explanation strings should be printed when options are listed. If no
explanation string is given but the tt(auto-describe) style is
set and only one argument is described for this var(opt-spec), the
option will be described by the value of the style with any appearance
of the sequence `tt(%d)' in it replaced by the description for the
first argument.
)
enditem()

In each of the cases above, the var(action) says how the possible
completions should be generated. In cases where only one of a fixed
set of strings can be completed, these string can directly be given as 
a list in parentheses, as in `tt(:foo:(foo bar baz))'. Such a list in
doubled parentheses, as in `tt(:foo:((a\:bar b\:baz)))' should contain 
strings consisting of the string to complete followed by a colon
(which needs to be preceded by a backslash) and a description. The
matches will be listed together with their descriptions if the
tt(description) style for the tt(values) tag is set.

An var(action) of the form `tt(->)var(string)' is used by functions
that implement a state machine. In this case, the `var(string)' (with
all leading and trailing spaces and tabs removed) will be stored in
the global parameter tt(state) and the function returns with a return
value of 300 (to make it distinguishable from other return values)
after setting the global `tt(context)', `tt(line)' and `tt(opt_args)'
parameters as described below and without resetting any changes made
to the special parameters such as tt(PREFIX) and tt(words). Note that
this means that a function calling tt(_arguments) with at least one
action containing such a `tt(->)var(string)' has to declare
appropriate local parameters as in:

example(local context state line
typeset -A opt_args)

This will ensure that tt(_arguments) does not create unused global
parameters.

A string in
braces will be evaluated to generate the matches and if the
var(action) does not begin with an opening parentheses or brace, it
will be split into separate words and executed. If the var(action)
starts with a space, this list of words will be invoked unchanged,
otherwise it will be invoked with some extra strings placed after the
first word which can be given as arguments to the tt(compadd) builtin
command and which make sure that the var(message) given
in the description will be shown above the matches. These arguments
are taken from the array parameter tt(expl) which will be set up
before executing the var(action) and hence may be used in it (normally 
in an expansion like `tt($expl[@])').

In places where no sensible matches can be generated, the action
should consist of only a space. This will make the var(message) be
displayed but no possible completions listed. Note that even in this
case the colon at the end of the var(message) is needed. The only case 
where it can be left is when neither a var(message), nor a var(action) 
is given.

To include a colon in the option name, the var(message) or the
var(action), it has to be preceded by a backslash.

During the evaluation or execution of the action the array `tt(line)'
will be set to the command name and normal arguments from the command
line, i.e. to the words from the command line excluding all options
and their arguments. These are stored in the associative array
`tt(opt_args)', using the option names as keys and their arguments as
the values. For options that have more than one argument these are
given as one string, separated by colons. All colons in the original
arguments are preceded with backslashes. The parameter `tt(context)'
will be set to the automatically created context name. This is either
a string of the form `var(-opt)tt(-)var(n)' for the var(n)'th argument 
of the option var(-opt), or a string of the form `tt(argument-)var(n)' 
for the var(n)'th argument (for rest arguments the var(n) is the
string `tt(rest)'). For example, when completing the argument of the tt(-o)
option, the name is `tt(-o-1)' and for the second normal (non-option-)
argument it is `tt(argument-2)'.

Also, during the evaluation of the var(action), the context name in
the tt(curcontext) parameter will be changed by appending the same
string that is stored in the tt(context) parameter.

Normally the option names are taken as multi-character names and a
word from the line is considered to contain only one option (or
none). By giving the tt(-s) option to this function (before the first
description), options are considered to be one-character options and the
strings from the line may contain more than one such option
letter. However, strings beginning with two hyphens (like
`tt(-)tt(-prefix)') are still considered to contain only one option
name. This allows the use of the `tt(-s)' option to describe
single-letter options together with such long option names.

Another option supported is `tt(-O) var(name)'. The var(name) will be
taken as the name of an array and its elements will be given to
functions called to generate matches when executing the
var(actions). For example, this allows one to give options for the
tt(compadd) builtin that should be used for all var(action)s.

Also, the tt(-M) option followed by a string may be given before the
first description. The string will be used as the match specification
when completing option names and values instead of the default
`tt(r:|[_-]=* r:|=*)'. 

Finally, the option tt(-C) can be given to make tt(_arguments) modify
the tt(curcontext) parameter when a action of the form
`tt(->)var(state)' is used. This parameter is used to keep track of
the current context and in this case it (and not the parameter
tt(context) as explained above) has to be made local to make sure that 
calling functions don't use the modified value. Also, the local
version of tt(curcontext) has to be initialised with the old value as
in:

example(local curcontext="$curcontext")

The function can also be made to automatically complete long options
for commands that support the `tt(-)tt(-help)' option as, for example,
most of the GNU commands do. For this, the string `tt(-)tt(-)' must be
given as one argument and if it is, the command from the line is
invoked with the `tt(-)tt(-help)' option and its output is parsed to find
possible option names. Note that this means that you should be careful
to make sure that this feature is not used for a command that does not
support this option.

For such automatically found options that get an argument after a
`tt(=)', the function also tries
to automatically find out what should be completed as the argument.
The possible completions for option-arguments can be described with
the arguments after the `tt(-)tt(-)' (which are not used as described
above). Each argument contains one description of the form
`var(pattern)tt(:)var(message)tt(:)var(action)'. The var(message) and
the var(action) have the same format as for the normal option
descriptions described above. The var(action) will be executed to
complete arguments of options whose description in the output of the
command from the line with the `tt(-)tt(-help)' option matches the
var(pattern). For example:

example(_arguments -- '*\*:toggle:(yes no)' \ 
              '*=FILE*:file:_files' \ 
              '*=DIR*:directory:_files -/')

Here, `tt(yes)' and `tt(no)' will be completed as the argument of
options whose description ends in a star, file names for options that
contain the substring `tt(=FILE)' in the description, and paths for
options whose description contains `tt(=DIR)'. In fact, the last two
patterns are not needed since this function always completes files
for option descriptions containing `tt(=FILE)' and paths for option
descriptions that contain `tt(=DIR)' or `tt(=PATH)'. These builtin
patterns can be overridden by patterns given as arguments, however.

Note also that tt(_arguments) tries to find out automatically if the
argument for an option is optional. If it fails to automatically
detect this, the colon before the var(message) can be doubled to tell
it about this as described for the normal option descriptions above.

The option `tt(-i) var(patterns)' (which must be given after the
`tt(-)tt(-)') can be used to give patterns for options which should not be
completed. The patterns can be given as the name of an array parameter
or as a literal list in parentheses. E.g. `tt(-i
"LPAR()-)tt(-(en|dis)able-FEATURE*RPAR()")' will make the options
`tt(-)tt(-enable-FEATURE)' and `tt(-)tt(-disable-FEATURE)' be ignored. The
option `tt(-s) var(pairs)' (again, after the `tt(-)tt(-)') can be used to
describe option aliases. Each var(pair) consists of a pattern and a
replacement. E.g. some tt(configure)-scripts describe options only as
`tt(-)tt(-enable-foo)', but also accept `tt(disable-foo)'. To allow
completion of the second form, one would use `tt(-s "LPAR()#-)tt(-enable-
-)tt(-disable-RPAR()")'.

Finally, this function uses the styles tt(description),
tt(prefix-hidden) and tt(prefix-needed) with the tt(options) tag when
generating option names as matches.

Example:

example(_arguments '-l+:left border:' \ 
           '-format:paper size:(letter A4)' \ 
           '*-copy:output file:_files::resolution:(300 600)' \ 
           ':postscript file:_files -g *.(ps|eps)' \ 
           '*:page number:')

This describes three options: `tt(-l)', `tt(-format)', and
`tt(-copy)'. The first one gets one argument described as `var(left
border)' for which no completion will be offered because of the empty
action. The argument may come directly after the `tt(-l)' or it may be 
given as the next word on the line. The `tt(-format)' option gets one
argument (in the next word) described as `var(paper size)' for which
only the strings `tt(letter)' and `tt(A4)' will be completed. The
`tt(-copy)' option differs from the first two in that it may appear
more than once on the command line and in that it accepts two
arguments. The first one is mandatory and will be completed as a
filename. The second one is optional (because of the second colon
before the description `var(resolution)') and will be completed from
the strings `tt(300)' and `tt(600)'.

The last two descriptions say what should be completed as
arguments. The first one describes the first argument as a
`var(postscript file)' and makes files ending in `tt(ps)' or `tt(eps)' 
be completed. The last description says that all other arguments are
`var(page numbers)' but does not give possible completions.
)
item(tt(_values))(
This is used to complete values (strings) and their arguments or
lists of such values.

If the first argument is the option `tt(-O) var(name)', this will be
used in the same way as by the tt(_arguments) function. I.e. the
elements of the var(name) array will be given to calls to tt(compadd)
and when executing an action.

Otherwise, if the first argument (or the first argument after the
`tt(-O) var(name)' option if that is used) is the option `tt(-s)', the
next argument is used as the character that separates multiple values.

The first argument (after the options and separator character if they
are given) is used as a string to print as a description before
listing the values.

All other arguments describe the possible values and their
arguments in the same format used for the description of options by
the tt(_arguments) function (see above). The only difference is that
there is no required minus or plus sign at the beginning and that
values can have only one argument.

Example:

example(_values -s , 'description' \ 
        '*foo[bar]' \
        '(two)*one[number]:first count:' \ 
        'two[another number]::second count:(1 2 3)')

This describes three possible values: `tt(foo)', `tt(one)', and
`tt(two)'. The first one is described as `tt(bar)', gets no argument 
and may appear more than once. The second one is described as
`tt(number)', may appear more than once, and gets one mandatory
argument described as `tt(first count)' for which no action is
specified so that it will not be completed automatically. The
`tt((two))' at the beginning says that if the value `tt(one)' is on
the line, the value `tt(two)' will not be  considered to be a possible
completion any more. Finally, the last value (`tt(two)') is described
as `tt(another number)' and gets an optional argument decribed as
`tt(second count)' which will be completed from the strings `tt(1)',
`tt(2)', and `tt(3)'. The tt(_values) function will complete lists of
these values separated by commas.

Like tt(_arguments) this function temporarily adds another context
name component to the current context name while executing the
var(action). Here this name is just the name of the value for which
the argument is completed.

To decide if the descriptions for the values (not those for the
arguments) should be printed, the style tt(description) for the
tt(values) tag is used.

One last difference to tt(_arguments) is that this function uses the
associative array
tt(val_args) to report values and their arguments (but otherwise this
is the same as the tt(opt_args) association used by
tt(_arguments)). This also means that the function calling tt(_values) 
should declare the tt(state), tt(line), tt(context) and tt(val_args)
parameters as in:

example(local context state line
typeset -A val_args)

when using an action of the form `tt(->)var(string)'. With this
function the tt(context) parameter will be set to the name of the
value whose argument is to be completed.

Like tt(_arguments), tt(_values) also supports the tt(-C) option in
which case you have to make the parameter tt(curcontext) local instead 
of tt(context) (as described above).
)
item(tt(_regex_arguments))(
This function is a compiler to generate a completion function.  The
first argument specifies the name of generated function and rest arguments
specifies a completion specification in the notation like regular
expression with acions.  The generated function is formed as a state
machine whose state corresponds each part of the specification of the
completion. The state machine runs on a command line and evaluate actions
when the command line is exhausted.  The command line is represented by
single string that is generated by concatinating unquoted tt(words)
(before tt(CURRENT)) and tt(PREFIX) using the null character as a
separator.

The specification is one of following forms.  (Metacharacters such as
`tt(LPAR())', `tt(RPAR())', `tt(#)' and `tt(|)' should be quoted.)
startitem()
item(tt(/)var(pattern)tt(/) [tt(%)var(lookahead)tt(%)] [tt(-)var(guard)] [tt(:)var(action)])(
This is a primitive element for the specification and corresponds to the
state of the compiled state machine.  When the state machine is trying to
enter to this state, the state machine tries to match the pattern
`tt((#b)LPAR()(#B))var(pattern)tt(RPAR()(#B))var(lookahead)tt(*)' against to
the command line string.  If it is matched, `var(guard)' is evaluated and
its return status is examined.  If it is success, the state machine is
entered to this state.  Otherwise when the pattern match or the guard
evaluation is failed, the state machine is failed to enter to this state
and other candidates are tried.  If `var(pattern)' is the string `tt([])',
it is treated as the pattern which never match.

When the state machine is entered to this state, the left part of the
command line string matched against to `var(pattern)' is removed and next
states of this state are tried to enter with inner-to-outer, left-to-right
fashion.

If all tries are failed and remaining command line string contains no null
character, completion target is restricted to correspondence of remaining
command line string and `var(action)'s for the target is evaluated.  Since
this state may not remove non-empty string from command line string,
prior states and its neighborhoods may have `var(actions)'s for the
target.
)
item(tt(/)var(pattern)tt(/+) [tt(%)var(lookahead)tt(%)] [tt(-)var(guard)] [tt(:)var(action)])(
This is similar to `tt(/)var(pattern)tt(/) ...' but the left part of
command line string is also considered as part of the completion target.
)
item(tt(/)var(pattern)tt(/-) [tt(%)var(lookahead)tt(%)] [tt(-)var(guard)] [tt(:)var(action)])(
This is similar to `tt(/)var(pattern)tt(/) ...' but `var(action)'s of this
and prior states are ignored even if following state's `var(pattern)'
matches empty string.
)
item(tt(LPAR()) var(spec) tt(RPAR()))(
This groups `var(spec)'.
)
item(var(spec) tt(#))(
This is repetation of `var(spec)'.
)
item(var(spec) var(spec))(
This is concatination of two `var(spec)'s.
)
item(var(spec) tt(|) var(spec))(
This is alternation of two `var(spec)'s.
)
enditem()
)
item(tt(_combination))(
This function is used to complete combinations of values such as pairs 
of hostnames and usernames. The possible values will be taken from the 
style whose name is given as the second argument. The first argument
is the tag to use to do the lookup.

The style name should consist of multiple parts separated with
hyphens which are then used as fieldnames. Known values for such
fields can be given after the second argument in arguments of the form 
`var(fiels)tt(=)var(pattern)'. The first argument without a equal sign 
is taken as the name of the field for which completions should be
generated.

The matches generated will be taken from the value of the style. These 
values should contain the possible values for the combinations where
the values for the different fields are separated by colons or the
character given after the tt(-s) option to tt(_combination).

Only the values for the requested fields for which the patterns given
in the `var(field)tt(=)var(pattern)' match the respective fields in
the strings from the style value are generated as possible matches.

If no style with the given name is defined for the given tag but a
function named with the name of the requestd field preceded by an
underscore is defined, that function will be called to generate the
matches. This is also done if none of the strings in the value of the
style match all the patterns given as arguments.

If the same name is used for more than one field, in both the
`var(field)tt(=)var(pattern)' and the argument that gives the field
name to complete for, the number of the field (starting with one) may
be given after the fieldname (separated from it by a colon).

All arguments after the requested fieldname are given to the
tt(compadd) used (when generating matches from the style value) and to 
the functions for the fields if they are called.
)
enditem()

texinode(Completion Directories)()(Completion Functions)(Completion System)
sect(Completion Directories)
cindex(completion system, directory structure)

In the source distribution, the files are contained in various
subdirectories of the tt(Completion) directory.  They may have been
installed in the same structure, or into one single function directory.
The following is a description of the files found in the original directory
structure.  If you wish to alter an installed file, you will need to copy
it to some directory which appears earlier in your tt(fpath) than the
standard directory where it appears.

startitem()
item(tt(Core))(
The core scripts and functions.  You will certainly need these, though will
probably not need to alter them.  Many of these are documented above.
)
item(tt(Base))(
Other functions you will almost certainly want if you are going to use
any of the standard completion functions.  You may want to edit some of
these files.
)
item(tt(Builtins))(
Functions for completing arguments of shell builtin commands.
)
item(tt(User))(
Functions for completing arguments of external commands and suites of
commands.  They may need modifying for your system.
)
item(tt(Commands))(
Functions which implement special types of completion to be bound to
keystrokes rather than called by context.
)
enditem()
