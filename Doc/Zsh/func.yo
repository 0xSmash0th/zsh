texinode(Functions)(Jobs & Signals)(Command Execution)(Top)
chapter(Functions)
ifzman(\
sect(Functions)
)\
cindex(functions)
findex(function)
Shell functions are defined with the tt(function) reserved word or the
special syntax `var(funcname) tt(())'.
Shell functions are read in and stored internally.
Alias names are resolved when the function is read.
Functions are executed like commands with the arguments
passed as positional parameters.
(See noderef(Command Execution).)

Functions execute in the same process as the caller and
share all files
and present working directory with the
caller.  A trap on tt(EXIT) set inside a function
is executed after the function completes in the environment
of the caller.

findex(return, use of)
The tt(return) builtin is used to return from function calls.

findex(functions, use of)
Function identifiers can be listed with the tt(functions) builtin.
findex(unfunction, use of)
Functions can be undefined with the tt(unfunction) builtin.
sect(Autoloading Functions)
findex(autoload, use of)
cindex(autoloading functions)
cindex(functions, autoloading)
A function can be marked as em(undefined) using the tt(autoload) builtin
(or `tt(functions -u)' or `tt(typeset -fu)').  Such a function has no
body.  When the function is first executed, each element of the tt(fpath)
variable will first be searched for a file with the same name as the
function plus the extension tt(.zwc) and then with the name of the
function.  The first file will only be used if it was created with the 
tt(zcompile) builtin command, if it contains the wordcode for the
function and it is either older than the file with the name of the
function in the same directory or if such a file does not exist.  The
usual alias expansion during reading will be suppressed
if the tt(autoload) builtin or its equivalent is given the option
tt(-U), for wordcode files this has to be decided when creating the
file with the tt(-U) option of the tt(zcompile) builtin command;
this is recommended for the use of functions supplied with the zsh
distribution.  Thus to define functions for autoloading, a typical sequence
is:

example(fpath=(~/myfuncs $fpath)
autoload myfunc1 myfunc2 ...)

The elements of the tt(fpath) array may also name wordcode files
directly. The names of these files must have the tt(.zwc) extension
but in tt(fpath) the names may be given with or without it. This is
mostly useful for wordcode files containing multiple 
functions, in which case the file is treated like a directory
containing files for functions and will be searched for the definition 
of the function.

pindex(KSH_AUTOLOAD, use of)
If the tt(KSH_AUTOLOAD) option is set, or the file contains only a simple
definition of the function, the file's contents will be
executed.  It will normally define the function in question, but may
also perform initialization:  this
is executed in the context of the function
execution, and may therefore define local parameters.  It is an error if
the function is not defined by loading the file.

Otherwise, the function is defined such that its body is the complete
contents of the file.  This form allows the file to be used directly as an
executable shell script.  If processing of the file results in the function
being re-defined, the function itself is not re-executed. To force the
function to perform initialization and be called, the file should contain
initialization code (which will be discarded) in addition to a complete
function definition (which will be retained for subsequent calls to the
function), and a call to the shell function at the end.

For example, suppose the autoload file tt(func) contains

example(func() { print This is func; }
print func is initialized
)

then `tt(func; func)' with tt(KSH_AUTOLOAD) set will produce both messages
on the first call, and just the message `tt(This is func)' on the second
and any subsequent calls.  Without tt(KSH_AUTOLOAD) set, it will produce
the initialization message on the first call, and the other message on the
second and subsequent calls.

It is also possible to create a function that is not marked autoloaded,
yet loads its own definition by searching tt(fpath): `tt(autoload -X)',
when called from within a shell function tt(myfunc), is equivalent to:

example(unfunction myfunc
autoload myfunc
myfunc "$@")

In fact, the tt(functions) command outputs `tt(builtin autoload -X)' as
the body of an autoloaded function.  A true autoloaded function can be
identifed by the presence of the comment `tt(# undefined)' in the body,
because all comments are discarded from defined functions.  This is done
so that

example(eval "$(functions)")

produces a reasonable result.

To load the definition of an autoloaded function tt(myfunc) without
executing tt(myfunc), use:

example(autoload +X myfunc)

sect(Special Functions)
The following functions, if defined, have special meaning to
the shell:

startitem()
findex(chpwd)
item(tt(chpwd))(
Executed whenever the current working directory is changed.
)
findex(periodic)
item(tt(periodic))(
vindex(PERIOD)
If the parameter tt(PERIOD)
is set, this function is executed every tt($PERIOD)
seconds, just before a prompt.
)
findex(precmd)
item(tt(precmd))(
Executed before each prompt.
)
findex(preexec)
item(tt(preexec))(
Executed just after a command has been read and is about to be
executed.  If the history mechanism is active, the string to be
executed is passed as an argument.
)
item(tt(TRAP)var(NAL))(
cindex(signals, trapping)
cindex(trapping signals)
If defined and non-null,
this function will be executed whenever the shell
catches a signal tt(SIG)var(NAL), where var(NAL) is a signal
name as specified for the tt(kill) builtin.
The signal number will be passed as the first parameter to the function.

If a function of this form is defined and null,
the shell and processes spawned by it will ignore tt(SIG)var(NAL).
)
findex(TRAPDEBUG)
item(tt(TRAPDEBUG))(
Executed after each command.
)
findex(TRAPEXIT)
item(tt(TRAPEXIT))(
Executed when the shell exits,
or when the current function exits if defined inside a function.
)
findex(TRAPZERR)
item(tt(TRAPZERR))(
Executed whenever a command has a non-zero exit status.
)
enditem()

The functions beginning `tt(TRAP)' may alternatively be defined with the
tt(trap) builtin:  this may be preferable for some uses, as they are then
run in the environment of the calling process, rather than in their own
function environment.
