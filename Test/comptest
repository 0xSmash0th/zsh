#!/usr/local/bin/zsh -f

[[ -d $ZTST_testdir/Modules/zsh ]] && module_path=( $ZTST_testdir/Modules )

zmodload -i zsh/zpty
setopt extendedglob

fpath=( $ZTST_srcdir/../(Completion|Functions)/*~*/CVS(/) )

debug=
dump=(-D)
code=
zsh=${ZSH:-zsh}
termcap_ce="$(echotc ce)"

debug=yes
while getopts Dd:c:z: opt; do
  case $opt in
    D) debug=yes;;
    d) dump=(-d "$OPTARG");;
    c) code="$OPTARG";;
    z) zsh="$OPTARG";;
  esac
done
(( OPTIND > 1 )) && shift $(( OPTIND - 1 ))

input="$*"

tmp=/tmp/comptest.$$

cat <<End >$tmp
module_path=( $module_path )
fpath=( $fpath )
stty columns 80 rows 24
LISTMAX=10000000
ZLS_COLORS='no=<NO>:fi=<FI>:di=<DI>:ln=<LN>:pi=<PI>:so=<SO>:bd=<BD>:cd=<CD>:ex=<EX>:mi=<MI>:tc=<TC>:sp=<SP>:lc=<LC>:ec=<EC>\n:rc=<RC>'
bindkey -e
autoload -U compinit
compinit $dump
zstyle ":completion:*" group-name ""
zstyle ":completion*:messages" format "<MESSAGE>%d</MESSAGE>
"
zstyle ":completion*:descriptions" format "<DESCRIPTION>%d</DESCRIPTION>
"
zstyle ":completion*:options" verbose yes
zstyle ":completion*:values" verbose yes
setopt noalwayslastprompt listrowsfirst completeinword
zmodload zsh/complist
expand-or-complete-with-report () {
  print -lr "<WIDGET><expand-or-complete>"
  zle expand-or-complete
  print -lr - "<LBUFFER>\$LBUFFER</LBUFFER>" "<RBUFFER>\$RBUFFER</RBUFFER>"
  zle clear-screen
  zle -R
}
list-choices-with-report () {
  print -lr "<WIDGET><list-choices>"
  zle list-choices
  zle clear-screen
  zle -R
}
finish () {
  print "<WIDGET><finish>"
  sleep 1
  exit 0
}
zle -N expand-or-complete-with-report
zle -N list-choices-with-report
zle -N finish
bindkey "^I" expand-or-complete-with-report
bindkey "^D" list-choices-with-report
bindkey "^Z" finish
$code
End

export PS1="<PROMPT>"
zpty zsh "$zsh" -f

zpty -r zsh log1 "*<PROMPT>*" || { 
  print first prompt doesn\'t appered.
  exit 1
}

zpty -w zsh ". $tmp"
zpty -r zsh log2 "*<PROMPT>*" || {
  print second prompt doesn\'t appered.
  exit 1
}
rm $tmp

zpty -n -w zsh "$input"$'\C-Z'
zpty -r zsh log "*<WIDGET><finish>*" || {
  print finish widget doesn\'t invoked.
  exit 1
}

if [[ -n "$debug" ]]; then
  print -lr - "$log" > /tmp/comptest.debug
fi

logs=(${(s:<WIDGET>:)log})
shift logs

for log in "$logs[@]"; do
  if [[ "$log" = (#b)*$'<LBUFFER>'(*)$'</LBUFFER>\r\n<RBUFFER>'(*)$'</RBUFFER>'* ]]; then
    print -lr "line: {$match[1]}{$match[2]}"
  fi
  while (( ${(N)log#*(#b)(<LC><(??)><RC>(*)<EC>|<DESCRIPTION>(*)</DESCRIPTION>|<MESSAGE>(*)</MESSAGE>|<COMPADD>(*)</COMPADD>)} )); do
    log="${log[$mend[1]+1,-1]}"
    if (( 0 <= $mbegin[2] )); then
      if [[ $match[2] != TC && $match[3] != \ # ]]; then
	print -lr "$match[2]:{${match[3]%$termcap_ce}}"
      fi
    elif (( 0 <= $mbegin[4] )); then
      print -lr "DESCRIPTION:{$match[4]}"
    elif (( 0 <= $mbegin[5] )); then
      print -lr "MESSAGE:{$match[5]}"
    elif (( 0 <= $mbegin[6] )); then
      result=`echo $match[6] | tr -d '\012\015'`
      print -lr "COMPADD:{$result}"
    fi
  done
done
